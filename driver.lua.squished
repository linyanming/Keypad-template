package.preload['common.c4_common'] = (function (...)
--[[=============================================================================
    ON_INIT, Timer,s and Property management functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_log"
require "lib.c4_timer"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_common = "2016.01.08"
end

--[[=============================================================================
    Create and Initialize Logging
===============================================================================]]
function ON_DRIVER_EARLY_INIT.c4_common()
	-- Create a logger
	LOG = c4_log:new("Template_c4z Change Name")
end

function ON_DRIVER_INIT.c4_common()
	-- Create Log Timer
	gC4LogTimer = c4_timer:new("Log Timer", 45, "MINUTES", OnLogTimerExpired)
end

--[[=============================================================================
    Log timer callback function
===============================================================================]]
function OnLogTimerExpired()
	LogWarn("Turning Log Mode Off (timer expired)")
	gC4LogTimer:KillTimer()
	
	C4:UpdateProperty("Log Mode", "Off")
	OnPropertyChanged("Log Mode")
end

gForceLogging = false
function ON_PROPERTY_CHANGED.LogMode(propertyValue)
	gC4LogTimer:KillTimer()
	
	if (gForceLogging) then
		LOG:OutputPrint(true)
		LOG:OutputC4Log(true)
	else
		LOG:OutputPrint(propertyValue:find("Print") ~= nil)
		LOG:OutputC4Log(propertyValue:find("Log") ~= nil)
		if (propertyValue == "Off") then
			return
		end
		
		gC4LogTimer:StartTimer()
	end
end

function ON_PROPERTY_CHANGED.LogLevel(propertyValue)
	if (gForceLogging) then
		LOG:SetLogLevel("5 - Debug")
	else
		LOG:SetLogLevel(propertyValue)
	end
end

--[[=============================================================================
    Print Template Versions
===============================================================================]]
function TemplateVersion()
	print ("\nTemplate Versions")
	print ("-----------------------")
	for k, v in pairs(TEMPLATE_VERSION) do
		print (k .. " = " .. v)
	end
	
	print ("")
end end)
package.preload['common.c4_device_connection_base'] = (function (...)
--[[=============================================================================
    DeviceConnectionBase Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_common"
require "lib.c4_object"
require "lib.c4_log"
require "lib.c4_timer"
require "lib.c4_queue"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_device_connection_base = "2016.01.08"
end

COMMAND_QUEUE_SIZE = 100
DEFAULT_COMMAND_DELAY_INTERVAL = 100            -- Don't send consecutive commands faster than this many milliseconds
DEFAULT_COMMAND_RESPONSE_INTERVAL = 3           -- If we haven't received and ACK after this many seconds, try again
DEFAULT_RETRY_COUNT_MAX = 3

function ON_DRIVER_EARLY_INIT.c4_device_connection_base()
	gReceiveBuffer = ""
	gIsUrlConnected = false
	gIsNetworkServerConnected = false
	gIsNetworkConnected = false
	gIsSerialConnected = false
	gIsIRConnected = false
end

DeviceConnectionBase = inheritsFrom(nil)

function DeviceConnectionBase:construct()

	self._IsConnected = false
	self._SendTimer = nil
	self._WaitResponseTimer = nil
	self._CommandQueue = nil
	self._Priority1CommandQueue = nil
	self._Priority2CommandQueue = nil
	self._LastCommand = nil
	self._ExpectAck = false
	self._CommandRetryCount = 0
	self._RetryCountMax = DEFAULT_RETRY_COUNT_MAX

	self._SendCommandDelayMS = DEFAULT_COMMAND_DELAY_INTERVAL
	self._CommandResponseWaitS = DEFAULT_COMMAND_RESPONSE_INTERVAL
	
	-- Polling
	self._PollingInterval = 0
	self._PollingUnits = "SECONDS"
	self._PollingTimer = nil
end

function DeviceConnectionBase:Initialize(ExpectAck, CommandDelayInterval, CommandResponseInterval, CallbackParam)

	if (ExpectAck ~= nil) then
		self._ExpectAck = ExpectAck
	end

	if (CommandDelayInterval ~= nil) then
		self._SendCommandDelayMS = CommandDelayInterval
	end

	if (CommandResponseInterval ~= nil) then
		self._CommandResponseWaitS = CommandResponseInterval
	end

	self._CommandQueue = c4_queue:new()
	self._CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._CommandQueue:SetName("Command Queue")

	self._Priority1CommandQueue = c4_queue:new()
	self._Priority1CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._Priority1CommandQueue:SetName("P1 Queue")

	self._Priority2CommandQueue = c4_queue:new()
	self._Priority2CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._Priority2CommandQueue:SetName("P2 Queue")

	-- usually only one of these timers will be used, but it's pretty low overhead to instantiate both of them
	self._SendTimer = c4_timer:new("SendCommand", self._SendCommandDelayMS, "MILLISECONDS", DeviceConnectionBase.OnSendTimeExpired, false, CallbackParam)
	self._WaitResponseTimer = c4_timer:new("WaitResponse", self._CommandResponseWaitS, "SECONDS", DeviceConnectionBase.OnWaitTimeExpired, false, CallbackParam)
end

function DeviceConnectionBase:InitPolling(PollingInterval, PollingUnits, CallbackParam)
	LogFatal("DeviceConnectionBase:InitPolling()")
	if (PollingInterval ~= nil) then
		self._PollingInterval = PollingInterval
	end
	
	self._PollingUnits = PollingUnits or self._PollingUnits

	LogFatal("self._PollingInterval: %s, self._PollingUnits: %s", tostring(self._PollingInterval), tostring(self._PollingUnits))
	
	-- create polling timer
	self._PollingTimer = c4_timer:new("Polling", self._PollingInterval, self._PollingUnits, DeviceConnectionBase.OnPollingTimerExpired, false, CallbackParam)
end

function DeviceConnectionBase:StartPolling(interval, units)
	LogFatal("DeviceConnectionBase:StartPolling()")
	LogFatal("self._PollingTimer: %s", tostring(self._PollingTimer))
	
	if (self._PollingTimer ~= nil) then
		self._PollingTimer:KillTimer()
		
		local timer_units = units or self._PollingTimer._units
		local timer_interval = interval or self._PollingInterval

		self._PollingTimer:StartTimer(timer_interval, timer_units)
	end
end

function DeviceConnectionBase:StopPolling()
	LogFatal("DeviceConnectionBase:StopPolling()")
	self._PollingTimer:KillTimer()
end

function DeviceConnectionBase:SetExpectACK(ExpectACK)
	self._ExpectAck = ExpectACK
end

function DeviceConnectionBase:SetCommandDelayInterval(DelayInterval)
	self._SendCommandDelayMS = DelayInterval
end

function DeviceConnectionBase:SetResponseWaitInterval(WaitInterval)
	self._CommandResponseWaitS = WaitInterval
end

function DeviceConnectionBase:ReceivedFromCom(sData)

	gReceiveBuffer = gReceiveBuffer .. sData
	LogTrace("ReceivedFromCom  ReceiveBuffer is now {{{%s}}}", gReceiveBuffer)

	message = self:GetMessage()
	LogTrace("ReceivedFromCom  message is now {{{%s}}}", message)
	while (message ~= nil and message ~= "") do
		status, err = pcall(HandleMessage, message)
		if (status) then
			message = self:GetMessage()
		else
			LogError("LUA_ERROR: " .. err)
			message = ""
			gReceiveBuffer = ""
		end
	end
end

function DeviceConnectionBase:SetConnection(IsConnected, method)
	self._IsConnected = IsConnected
	gControlMethod = method
end

function DeviceConnectionBase:ControlMethod()
	-- Override in derived class
	print("WARNING: Need to override ControlMethod - should never be called")
	
	return ""
end

function DeviceConnectionBase:StartCommandTimer(...)
	local value = select(1, ...)
	local units = select(2, ...)
	local command_name = select(3, ...) or ""

	self._WaitResponseTimer:KillTimer()
	self._SendTimer:KillTimer()

	if (self._ExpectAck) then
		-- expecting an ACK set the Response Wait timer
		local timer_units = units or self._WaitResponseTimer._units
		local timer_interval = value or self._CommandResponseWaitS

		self._WaitResponseTimer:StartTimer(timer_interval, timer_units)
		LogTrace(string.format("Starting wait Timer:  %d", self._WaitResponseTimer._timerID) .. " for " .. command_name)
	else
		-- no ACK expected, just wait the designated amount of time and send another command
		local timer_units = units or self._SendTimer._units
		local timer_interval = value or self._SendCommandDelayMS

		self._SendTimer:StartTimer(timer_interval, timer_units)
		LogTrace(string.format("Starting Send Timer:  %d for %s (timer_interval = %d, timer_units = %s)", self._SendTimer._timerID, command_name, timer_interval, timer_units))
	end
end

-- Note the '.' instead of the ':'
function DeviceConnectionBase.OnSendTimeExpired(Instance)
	LogTrace("Send Timer expired")
	Instance._SendTimer:KillTimer()

	local tCommand = Instance._LastCommand
	if (tCommand ~= nil) then
		if (tCommand.command_name ~= nil) then
			LogTrace("Send Timer expired - Last Command: %s, Send Next Command", tostring(tCommand.command_name))
		elseif (type(tCommand) == "string") then
			LogTrace("Send Timer expired - Last Command: %s, Send Next Command", tostring(tCommand))
		end
	else
		LogTrace("Send Timer expired - Last Command: UNKNOWN, Send Next Command")
	end
	
	Instance._LastCommand = nil
	Instance:SendNextCommand()

	if (DoEvents ~= nil and type(DoEvents) == "function") then
		DoEvents()
	end
end

function DeviceConnectionBase.OnWaitTimeExpired(Instance)
	LogTrace("Wait Timer expired")
	Instance._WaitResponseTimer:KillTimer()
	Instance._CommandRetryCount = Instance._CommandRetryCount + 1

	if (Instance._CommandRetryCount >= Instance._RetryCountMax) then
		-- To many retries, pop the current command and try the next one
		Instance._CommandRetryCount = 0
		Instance:SendNextCommand()
	else
		Instance:SendLastCommand()
	end
end

function DeviceConnectionBase.OnPollingTimerExpired(Instance)
	LogTrace("Polling Timer expired")
	Instance._PollingTimer:KillTimer()

	OnPollingTimerExpired()
	
	Instance._PollingTimer:StartTimer(Instance._PollingInterval)
end

function DeviceConnectionBase:HandleACK()
	self._LastCommand = nil
	
	self._WaitResponseTimer:KillTimer()
	self._CommandRetryCount = 0
	self:SendNextCommand()
end

function DeviceConnectionBase:QueueEmpty()
	return (self._CommandQueue:empty() and self._Priority1CommandQueue:empty() and self._Priority2CommandQueue:empty())
end

function DeviceConnectionBase:QueueCommand(sCommand, ...)
--	LogTrace("QueueCommand(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:QueuePriority1Command(sCommand, ...)
	LogTrace("QueuePriority1Command(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._Priority1CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._Priority1CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._Priority1CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:QueuePriority2Command(sCommand, ...)
	LogTrace("QueuePriority2Command(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._Priority2CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._Priority2CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._Priority2CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:SendNextCommand()
	LogTrace("DeviceConnectionBase:SendNextCommand")

	local tCommand = nil
	if (not self._Priority1CommandQueue:empty()) then
		tCommand = self._Priority1CommandQueue:pop()
		LogTrace(tostring(gCon._Priority1CommandQueue))
	elseif (not self._Priority2CommandQueue:empty()) then
		tCommand = self._Priority2CommandQueue:pop()
		LogTrace(tostring(gCon._Priority2CommandQueue))
	elseif (not self._CommandQueue:empty()) then
		tCommand = self._CommandQueue:pop()
		LogTrace(tostring(gCon._CommandQueue))
	end
	
	if (tCommand ~= nil) then
		self._LastCommand = tCommand
		local sCommand = tCommand.command
		local command_delay = tCommand.command_delay
		local delay_units = tCommand.delay_units
		local command_name = tCommand.command_name

		if (sCommand == nil or sCommand == "") then
			self._SendTimer:KillTimer()
			self._WaitResponseTimer:KillTimer()
		else
			LogTrace("SendCommand: %s", sCommand)
			self:SendCommand(sCommand, command_delay, delay_units, command_name)
		end
	end
end

function DeviceConnectionBase:SendLastCommand()
--	LogTrace("DeviceConnectionBase:SendLastCommand")

	local tCommand = self._LastCommand
	if (tCommand ~= nil) then
		local sCommand = tCommand.command
		local command_delay = tCommand.command_delay
		local delay_units = tCommand.delay_units
		local command_name = tCommand.command_name

		if (sCommand == nil or sCommand == "") then
			self._SendTimer:KillTimer()
			self._WaitResponseTimer:KillTimer()
		else
			LogTrace("SendCommand: %s", sCommand)
			self:SendCommand(sCommand, command_delay, delay_units, command_name)
		end
	end
end

function DeviceConnectionBase:SendCommand()
	-- Dummy routine.  Override in derived class
	print("Need to override SendCommand - should never be called")
end


function DeviceConnectionBase:GetMessage()
	
	-- Brain dead version of this routine. Just return the current receive buffer.
	-- It's very likely that a GetMessage() function will need to be created
	if (GetMessage ~= nil and type(GetMessage) == "function") then
		return GetMessage()
	else
		local ComMessage = gReceiveBuffer
		gReceiveBuffer = ""

		return ComMessage
	end
end

--[[=============================================================================
    Other Connection Functions
===============================================================================]]

function ReceivedFromSerial(idBinding, sData)
	if (gCon.ReceivedFromSerial == nil) then return end --serial is bound but not the current control method
	gCon:ReceivedFromSerial(idBinding, sData)
end

function ReceivedFromNetwork(idBinding, nPort, sData)
	gCon:ReceivedFromNetwork(idBinding, nPort, sData)
end

function OnServerDataIn(nHandle, strData)
--	LogTrace("Received Data on Handle: " .. nHandle .. ": " .. strData)
--	LogTrace("Data Is: %s", HexToString(strData))
	gCon:ReceivedFromNetworkServer(nHandle, strData)
end


--[[=============================================================================
    The ReceivedAsync function is called in response to 'url_get_request'. 
    The ticketId is the number returned from the request.
===============================================================================]]
function ReceivedAsync(ticketId, strData, responseCode, tHeaders)
	strData = strData or ""
	responseCode = responseCode or 0
	tHeaders = tHeaders or {}

--	LogTrace("ReceivedAsync[" .. ticketId .. "]: Response Code: " .. responseCode .. " Length: " .. string.len(strData))
--	LogTrace(tHeaders)

	gCon:ReceivedAsync(ticketId, strData, responseCode, tHeaders)
end
	
--[[=============================================================================
    OnBindingChanged(idBinding, class, bIsBound)
  
    Description:
    Function called by Director when a binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnBindingChanged(idBinding, class, bIsBound)
	
	LogTrace("OnBindingChanged(): idBinding = " .. tostring(idBinding) .. ", class = " .. class .. ", bIsBound = " .. tostring(bIsBound))
	if (idBinding == SERIAL_BINDING_ID) then
		gIsSerialConnected = bIsBound
		SetControlMethod()
		OnSerialConnectionChanged(idBinding, class, bIsBound)
	elseif (idBinding == IR_BINDING_ID) then
		gIsIRConnected = bIsBound
		SetControlMethod()
		OnIRConnectionChanged(idBinding, class, bIsBound)
	elseif(OnConnectionChanged ~= nil and type(OnConnectionChanged) == "function") then
		OnConnectionChanged(idBinding, class, bIsBound)
	end
end

--[[=============================================================================
    OnNetworkBindingChanged(idBinding, bIsBound)
  
    Description:
    Function called by Director when a network binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnNetworkBindingChanged(idBinding, bIsBound)
	LogTrace('OnNetworkBindingChanged(): idBinding = ' .. tostring(idBinding) .. ' bIsBound = ' .. tostring(bIsBound))

	gIsNetworkConnected = bIsBound
	SetControlMethod()
	OnNetworkConnectionChanged(idBinding, bIsBound)
	if (bIsBound) then
		-- Start a special instance of reconnect timer to eventually do NetConnect if not done automatically
		gCon._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval) 	
	end	
end

--[[=============================================================================
    OnConnectionStatusChanged(idBinding, nPort, sStatus)
  
    Description:
    Sets the updated status of the specified binding
  
    Parameters:
    idBinding(int)  - ID of the binding whose status has changed
    nPort(int)      - The communication port of the specified bindings connection
    sStatus(string) - "ONLINE" if the connection status is to be set to Online,
                      any other value will set the status to Offline
  
    Returns:
    None
===============================================================================]]
function OnConnectionStatusChanged(idBinding, nPort, sStatus)
	LogTrace("OnConnectionStatusChanged[" .. idBinding .. " (" .. tostring(nPort) .. ")]: " .. sStatus)

	local isOnline = false

	gNetworkStatus = sStatus	
	if (sStatus == "ONLINE") then
		isOnline = true
	end

	gCon:SetOnlineStatus(isOnline)
	OnNetworkStatusChanged(idBinding, nPort, sStatus)
end

--[[=============================================================================
    SetControlMethod()
  
    Description:
    Sets the control method type for the drivers internal infrastructure
  
    Parameters:
    None
  
    Returns:
    The type of control method for the drivers connection(i.e. Network, Serial,
    IR, or (none))
===============================================================================]]
function SetControlMethod()
	if (gCon ~= nil) then
		if (gIsNetworkConnected == false) and (gCon._NetworkReconnectTimer ~= nil) then
			--housekeeping when changing from network control to serial or IR control
			gCon._NetworkReconnectTimer:KillTimer() 
		end
	end


	if( gIsNetworkServerConnected) then
		-- connect to NetworkServer communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "NetworkServer") then
			gCon = NetworkServerConnectionBase:new()
			gCon:Initialize()
		end
		gCon:SetConnection(true, "NetworkServer")
	elseif (gIsNetworkConnected) then
		-- connect to Network communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "Network") then
			gCon = NetworkConnectionBase:new(NETWORK_BINDING_ID, NETWORK_PORT)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "Network")
	elseif (gIsUrlConnected) then
		-- connect to URL communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "URL") then
			gCon = UrlConnectionBase:new()
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "URL")
	elseif (gIsSerialConnected) then
		-- connect to Serial communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "Serial") then
			gCon = SerialConnectionBase:new(SERIAL_BINDING_ID)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
			gCon:InitPolling(tonumber(gPollingTimerInterval), "MINUTES", gCon)
		end
		gCon:SetConnection(true, "Serial")
	elseif (gIsIRConnected) then
		-- connect to IR communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "IR") then
			gCon = IRConnectionBase:new(IR_BINDING_ID)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "IR")
	else
		if (gCon ~= nil) then
			gCon:SetConnection(false, "(none)")
		end
		-- gCon = nil
	end

	gCon._CommandQueue:clear()
	gCon._Priority1CommandQueue:clear()
	gCon._Priority2CommandQueue:clear()
end

--[[=============================================================================
    ValidateControlMethod(controlMethod)
  
    Description:
    Identifies whether the specified control method has a valid connection
  
    Parameters:
    controlMethod(string) - The communication we are validating against
                            Valid types are (Network, Serial, and IR)
  
    Returns:
    true if the controlMethod specified has been connected, false otherwise.
===============================================================================]]
function ValidateControlMethod(controlMethod)
	local isValid = false

	if (controlMethod == "Network") and (gIsNetworkConnected) then
		isValid = true
	elseif (controlMethod == "URL") and (gIsUrlConnected) then
		isValid = true
	elseif (controlMethod == "Serial") and (gIsSerialConnected) then
		isValid = true
	elseif (controlMethod == "IR") and (gIsIRConnected) then
		isValid = true
	end

	return isValid
end
 end)
package.preload['common.c4_driver_declarations'] = (function (...)
--[[=============================================================================
    Driver Declarations used to call startup routines, teardown routines, and 
    other basic functions of the drivers operation

    Copyright 2017 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Template Version Table
TEMPLATE_VERSION = {}
TEMPLATE_VERSION.c4_driver_declarations = "2017.04.25"

-- Command Handler Tables
EX_CMD = {}
PRX_CMD = {}
UI_REQ = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}
PROG_CONDITIONAL = {}


--[[=============================================================================
    Tables of functions
    The following tables are function containers that are called within the
    following functions:

    OnDriverInit()
        First calls all functions contained within ON_DRIVER_EARLY_INIT table
        then calls all functions contained within ON_DRIVER_INIT table

    OnDriverLateInit()
        Calls all functions contained within ON_DRIVER_LATEINIT table

    OnDriverDestroyed()
        Calls all functions contained within ON_DRIVER_DESTROYED table

    OnPropertyChanged()
        Calls all functions contained within ON_PROPERTY_CHANGED table
===============================================================================]]
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}

-- Constants
DEFAULT_PROXY_BINDINGID = 5001 end)
package.preload['common.c4_init'] = (function (...)
--[[=============================================================================
    Initial driver initialization and destruction functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_property"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_init = "2016.01.08"
end

--[[=============================================================================
    OnDriverInit()

    Description
    Invoked by director when a driver is loaded. This API is provided for the
    driver developer to contain all of the driver objects that will require
    initialization.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverInit()
	gInitializingDriver = true
	C4:ErrorLog("INIT_CODE: OnDriverInit()")

	-- Call all ON_DRIVER_EARLY_INIT functions.
	for k,v in pairs(ON_DRIVER_EARLY_INIT) do
		if (ON_DRIVER_EARLY_INIT[k] ~= nil and type(ON_DRIVER_EARLY_INIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_EARLY_INIT." .. k .. "()")
			local status, err = pcall(ON_DRIVER_EARLY_INIT[k])
			if (not status) then
				C4:ErrorLog("LUA_ERROR: " .. err)
			end
		end
	end

	-- Call all ON_DRIVER_INIT functions
	for k,v in pairs(ON_DRIVER_INIT) do
		if (ON_DRIVER_INIT[k] ~= nil and type(ON_DRIVER_INIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_INIT." .. k .. "()")
			local status, err = pcall(ON_DRIVER_INIT[k])
			if (not status) then
				C4:ErrorLog("LUA_ERROR: " .. err)
			end
		end
	end

	-- Fire OnPropertyChanged to set the initial Headers and other Property
	-- global sets, they'll change if Property is changed.
	for k,v in pairs(Properties) do
		C4:ErrorLog("INIT_CODE: Calling OnPropertyChanged - " .. k .. ": " .. v)
		local status, err = pcall(OnPropertyChanged, k)
		if (not status) then
			C4:ErrorLog("LUA_ERROR: " .. err)
		end
	end

	gInitializingDriver = false
end

--[[=============================================================================
    OnDriverLateInit()

    Description
    Invoked by director after all drivers in the project have been loaded. This
    API is provided for the driver developer to contain all of the driver
    objects that will require initialization after all drivers in the project
    have been loaded.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverLateInit()
	C4:ErrorLog("INIT_CODE: OnDriverLateInit()")
	
	-- Call all ON_DRIVER_LATEINIT functions
	for k,v in pairs(ON_DRIVER_LATEINIT) do
		if (ON_DRIVER_LATEINIT[k] ~= nil and type(ON_DRIVER_LATEINIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_LATEINIT." .. k .. "()")
			ON_DRIVER_LATEINIT[k]()
		end
	end
end


--[[=============================================================================
    OnDriverDestroyed()
    Function called by Director when a driver is removed. Release things this
    driver has allocated such as timers.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverDestroyed()
	C4:ErrorLog("INIT_CODE: OnDriverDestroyed()")
	
	-- Call all ON_DRIVER_DESTROYED functions
	for k, v in pairs(ON_DRIVER_DESTROYED) do
		if (ON_DRIVER_DESTROYED[k] ~= nil and type(ON_DRIVER_DESTROYED[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_DESTROYED." .. k .. "()")
			ON_DRIVER_DESTROYED[k]()
		end
	end
end end)
package.preload['common.c4_ir_connection'] = (function (...)
--[[=============================================================================
    Base for an IR connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_device_connection_base"
require "lib.c4_log"
require "common.c4_common"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_ir_connection = "2016.01.08"
end

IRConnectionBase = inheritsFrom(DeviceConnectionBase)

function IRConnectionBase:construct(BindingID)
	self.superClass():construct()
	self._BindingID = BindingID
end

function IRConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	print("tSerConBase:Initialize")
	gControlMethod = "IR"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
end

function IRConnectionBase:ControlMethod()
	return "IR"
end

function IRConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		local command_delay = select(1, ...)
		local delay_units = select(2, ...)
		local command_name = select(3, ...)

		C4:SendIR(self._BindingID, sCommand)
		self:StartCommandTimer(command_delay, delay_units, command_name)
	else
		LogWarn("IR connection is not bound. Command not sent.")
	end
end
 end)
package.preload['common.c4_network_connection'] = (function (...)
--[[=============================================================================
    Base for a network connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_device_connection_base"
require "lib.c4_log"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_network_connection = "2016.01.08"
end

DEFAULT_POLLING_INTERVAL_SECONDS = 30
DEFAULT_RECONNECT_INTERVAL_SECONDS = 5

gNetworkKeepAliveInterval = DEFAULT_POLLING_INTERVAL_SECONDS
gNetworkReconnectInterval = DEFAULT_RECONNECT_INTERVAL_SECONDS

NetworkConnectionBase = inheritsFrom(DeviceConnectionBase)

function NetworkConnectionBase:construct(BindingID, Port)
	self.superClass():construct()

	self._BindingID = BindingID
	self._Port = Port
	self._LastCheckin = 0
	self._IsOnline = false
	self._KeepAliveTimer = nil
end

function NetworkConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	print("NetConBase:Initialize")
	gControlMethod = "Network"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
	self._KeepAliveTimer = c4_timer:new("PollingTimer", gNetworkKeepAliveInterval, "SECONDS", NetworkConnectionBase.OnKeepAliveTimerExpired, false, self)
	self._NetworkReconnectTimer = c4_timer:new("NetworkReconnectTimer", gNetworkReconnectInterval, "SECONDS", NetworkConnectionBase.OnNetworkReconnectTimerExpired, false, self)
end

function NetworkConnectionBase:ControlMethod()
	return "Network"
end

function NetworkConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		if(self._IsOnline) then
			local command_delay = select(1, ...)
			local delay_units = select(2, ...)
			local command_name = select(3, ...)

			C4:SendToNetwork(self._BindingID, self._Port, sCommand)
			self:StartCommandTimer(command_delay, delay_units, command_name)
		else
			self:CheckNetworkConnectionStatus()
		end
	else
		LogWarn("Not connected to network. Command not sent.")
	end
end

function NetworkConnectionBase:ReceivedFromNetwork(idBinding, nPort, sData)
	self._LastCheckin = 0
	self:ReceivedFromCom(sData)
end

function NetworkConnectionBase:CheckNetworkConnectionStatus()
	if (self._IsConnected and (not self._IsOnline)) then
		LogWarn("Network status is OFFLINE. Trying to reconnect to the device's Control port...")
		C4:NetDisconnect(self._BindingID, self._Port)
		--C4:NetConnect(self._BindingID, self._Port)
		self._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
	end
end

function NetworkConnectionBase.OnKeepAliveTimerExpired(Instance)
	Instance._LastCheckin = Instance._LastCheckin + 1

	if(Instance._LastCheckin == 3) then
		LogWarn("Failed to receive poll responses... initiating network recovery mode...")
		C4:NetDisconnect(Instance._BindingID, Instance._Port)
		Instance._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
		return
	elseif(Instance._LastCheckin > 4) then	
		Instance._LastCheckin = 4
	end

	if (SendKeepAlivePollingCommand ~= nil and type(SendKeepAlivePollingCommand) == "function" and Instance._IsOnline) then
		SendKeepAlivePollingCommand()
	end

	Instance._KeepAliveTimer:StartTimer(gNetworkKeepAliveInterval)
end

function NetworkConnectionBase.OnNetworkReconnectTimerExpired(Instance)
	if (Instance._IsConnected) then
		LogWarn("OnNetworkReconnectTimerExpired: Attempting to reactivate network connection...")
		C4:NetDisconnect(Instance._BindingID, Instance._Port)
		C4:NetConnect(Instance._BindingID, Instance._Port)
		Instance._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
	else
		LogWarn("Cannot attempt to reactivate, the network connection is not bound")
	end
end

function NetworkConnectionBase:SetOnlineStatus(IsOnline)
	self._IsOnline = IsOnline

	if(IsOnline) then
		self._KeepAliveTimer:StartTimer(gNetworkKeepAliveInterval)
		self._NetworkReconnectTimer:KillTimer()
		self._LastCheckin = 0
		if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			UpdateProperty("Connected To Network", "true")
		end

		self:SendNextCommand()
	else
		self._KeepAliveTimer:KillTimer()
		self._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
		if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			UpdateProperty("Connected To Network", "false")
		end
	end
end

function ON_DRIVER_LATEINIT.c4_network_connection()
	-- Ensure existing connection is taken into consideration (useful on Driver Update)
	if (gIsNetworkConnected) then
		if (gCon ~= nil and gCon._BindingID ~= nil) then
			local tmp = C4:GetBindingAddress(gCon._BindingID)
			if (tmp ~= nil and string.len(tmp) > 0) then 
				OnNetworkBindingChanged(gCon._BindingID, true) 
			end
		end
	end
end
 end)
package.preload['common.c4_notify'] = (function (...)
--[[=============================================================================
    Notification Functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_notify = "2016.01.08"
end

--[[=============================================================================
    SendNotify(notifyText, tParams, bindingID)

    Description
    Forwards a notification to the proxy with a list of parameters

    Parameters
    notifyText(string) - The function identifier for the proxy
    tParams(table)     - Table of key value pairs that hold the the parameters
                         and their values used in the proxy function
    bindingID(int)     - The requests binding id

    Returns
    Nothing
===============================================================================]]
function SendNotify(notifyText, tParams, bindingID)
	C4:SendToProxy(bindingID, notifyText, tParams, "NOTIFY")
end

--[[=============================================================================
    SendSimpleNotify(notifyText, ...)

    Description
    Forwards a notification to the proxy with no parameters

    Parameters
    notifyText(string) - The function identifier for the proxy
    bindingID(int)     - Optional parameter containing the requests binding id,
                         if not specified then the DEFAULT_PROXY_ID is given.

    Returns
    Nothing
===============================================================================]]
function SendSimpleNotify(notifyText, ...)
	bindingID = select(1, ...) or DEFAULT_PROXY_BINDINGID
	C4:SendToProxy(bindingID, notifyText, {}, "NOTIFY")
end end)
package.preload['common.c4_property'] = (function (...)
--[[=============================================================================
    Function for changing properties

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_property = "2016.01.08"
end

--[[=============================================================================
    OnPropertyChanged(sProperty)

    Description
    Function called by Director when a property changes value. The value of the
    property that has changed can be found with: Properties[sName]. Note that
    OnPropertyChanged is not called when the Property has been changed by the
    driver calling the UpdateProperty command, only when the Property is changed
    by the user from the Properties Page. This function is called by Director
    when a property changes value.

    Parameters
    sProperty(string) - Name of property that has changed.

    Returns
    Nothing
===============================================================================]]
function OnPropertyChanged(sProperty)
	local propertyValue = Properties[sProperty]

	if (LOG ~= nil and type(LOG) == "table") then
		LogTrace("OnPropertyChanged(" .. sProperty .. ") changed to: " .. Properties[sProperty])
	end

	-- Remove any spaces (trim the property)
	local trimmedProperty = string.gsub(sProperty, " ", "")
	local status = true
	local err = ""

	if (ON_PROPERTY_CHANGED[sProperty] ~= nil and type(ON_PROPERTY_CHANGED[sProperty]) == "function") then
		status, err = pcall(ON_PROPERTY_CHANGED[sProperty], propertyValue)
	elseif (ON_PROPERTY_CHANGED[trimmedProperty] ~= nil and type(ON_PROPERTY_CHANGED[trimmedProperty]) == "function") then
		status, err = pcall(ON_PROPERTY_CHANGED[trimmedProperty], propertyValue)
	end

	if (not status) then
		LogError("LUA_ERROR: " .. err)
	end
end

--[[=============================================================================
    UpdateProperty(propertyName, propertyValue)
  
    Description:
    Sets the value of the given property in the driver
  
    Parameters:
    propertyName(string)  - The name of the property to change
    propertyValue(string) - The value of the property being changed
  
    Returns:
    None
===============================================================================]]
function UpdateProperty(propertyName, propertyValue)
	if (Properties[propertyName] ~= nil) then
		C4:UpdateProperty(propertyName, propertyValue)
	end
end
 end)
package.preload['common.c4_command'] = (function (...)
--[[=============================================================================
    Functions for handling and executing commands and actions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_command = "2016.01.08"
end

--[[=============================================================================
    ExecuteCommand(sCommand, tParams)

    Description
    Function called by Director when a command is received for this DriverWorks
    driver. This includes commands created in Composer programming.

    Parameters
    sCommand(string) - Command to be sent
    tParams(table)   - Lua table of parameters for the sent command

    Returns
    Nothing
===============================================================================]]
function ExecuteCommand(sCommand, tParams)
	LogTrace("ExecuteCommand(" .. sCommand .. ")")
	LogInfo(tParams)

	-- Remove any spaces (trim the command)
	local trimmedCommand = string.gsub(sCommand, " ", "")
	local status, ret

	-- if function exists then execute (non-stripped)
	if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
		status, ret = pcall(EX_CMD[sCommand], tParams)
	-- elseif trimmed function exists then execute
	elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
		status, ret = pcall(EX_CMD[trimmedCommand], tParams)
	elseif (EX_CMD[sCommand] ~= nil) then
		QueueCommand(EX_CMD[sCommand])
		status = true
	else
		LogInfo("ExecuteCommand: Unhandled command = " .. sCommand)
		status = true
	end
	
	if (not status) then
		LogError("LUA_ERROR: " .. ret)
	end
	
	return ret -- Return whatever the function returns because it might be xml, a return code, and so on
end

--[[=============================================================================
    EX_CMD.LUA_ACTION(tParams)

    Description
    Function called for any actions executed by the user from the Actions Tab
    in Composer.

    Parameters
    tParams(table) - Lua table of parameters for the command option

    Returns
    Nothing
===============================================================================]]
function EX_CMD.LUA_ACTION(tParams)
	if (tParams ~= nil) then
		for cmd, cmdv in pairs(tParams) do
			if (cmd == "ACTION" and cmdv ~= nil) then
				local status, err = pcall(LUA_ACTION[cmdv], tParams)
				if (not status) then
					LogError("LUA_ERROR: " .. err)
				end
				break
			end
		end
	end
end

--[[=============================================================================
    ReceivedFromProxy(idBinding, sCommand, tParams)

    Description
    Function called for any actions executed by the user from the Actions Tab
    in Composer.

    Parameters
    idBinding(int)   - Binding ID of the proxy that sent a BindMessage to the
                       DriverWorks driver.
    sCommand(string) - Command that was sent
    tParams(table)   - Lua table of received command parameters

    Returns
    Nothing
===============================================================================]]
function ReceivedFromProxy(idBinding, sCommand, tParams)

	if (sCommand ~= nil) then

		-- initial table variable if nil
		if (tParams == nil) then
			tParams = {}
		end
		
		LogTrace("ReceivedFromProxy(): " .. sCommand .. " on binding " .. idBinding .. "; Call Function PRX_CMD." .. sCommand .. "()")
		LogInfo(tParams)

		if ((PRX_CMD[sCommand]) ~= nil) then
			local status, err = pcall(PRX_CMD[sCommand], idBinding, tParams)
			if (not status) then
				LogError("LUA_ERROR: " .. err)
			end
		else
			LogInfo("ReceivedFromProxy: Unhandled command = " .. sCommand)
		end
	end
end

--[[
	This function is called when a UI (Navigator) requests data, and
	calls the function requested.
--]]
function UIRequest(sRequest, tParams)
	local ret = ""

	if (sRequest ~= nil) then
		tParams = tParams or {}   -- initial table variable if nil
		LogTrace("UIRequest(): " .. sRequest .. "; Call Function UI_REQ." .. sRequest .. "()")
		LogInfo(tParams)

		if (UI_REQ[sRequest]) ~= nil then
			ret = UI_REQ[sRequest](tParams)
		else
			LogWarn("UIRequest: Unhandled request = " .. sRequest)
		end
	end

	return ret
end
 end)
package.preload['common.c4_serial_connection'] = (function (...)
--[[=============================================================================
    Base for a serial connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_device_connection_base"
require "lib.c4_log"
require "common.c4_common"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_serial_connection = "2016.01.08"
end

SerialConnectionBase = inheritsFrom(DeviceConnectionBase)

function SerialConnectionBase:construct(BindingID)
	self.superClass():construct()
	self._BindingID = BindingID
end

function SerialConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	gControlMethod = "Serial"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
end

function SerialConnectionBase:ControlMethod()
	return "Serial"
end

function SerialConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		local command_delay = select(1, ...)
		local delay_units = select(2, ...)
		local command_name = select(3, ...)

		C4:SendToSerial(self._BindingID, sCommand)
		self:StartCommandTimer(command_delay, delay_units, command_name)
	else
		LogWarn("Not connected to serial. Command not sent.")
	end
end

function SerialConnectionBase:SendRaw(sData)
	C4:SendToSerial(self._BindingID, sData)
end


function SerialConnectionBase:ReceivedFromSerial(idBinding, sData)
	self:ReceivedFromCom(sData)
end
 end)
package.preload['common.c4_url_connection'] = (function (...)
--[[=============================================================================
    Base for a url connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_device_connection_base"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_url_connection = "2016.01.08"
end

UrlConnectionBase = inheritsFrom(DeviceConnectionBase)

function UrlConnectionBase:construct(Url)
	self.superClass():construct()
	self._Url = Url
end

function UrlConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	gControlMethod = "URL"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
	OnURLConnectionChanged()
end

function UrlConnectionBase:ControlMethod()
	return "URL"
end

function UrlConnectionBase:SetUrl(Url)
	self._Url = Url
end

function UrlConnectionBase:SendCommand(sCommand, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(self._Url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(self._Url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:SendCommandUrl(sCommand, url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:UrlPost(sCommand, url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:UrlGet(url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlGet(url, sHeader)
		else
			ticketId = C4:urlGet(url)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:ReceivedAsync(ticketId, sData, responseCode, tHeaders)
	LogTrace("ReceivedAsync[" .. ticketId .. "]: Response Code: " .. responseCode .. " Length: " .. string.len(sData))
	LogTrace(tHeaders)
	local tMessage = {
		["ticketId"] = ticketId,
		["sData"] = sData,
		["responseCode"] = responseCode,
		["tHeaders"] = tHeaders
	}
	
	status, err = pcall(HandleMessage, tMessage)
	if (not status) then
		LogError("LUA_ERROR: " .. err)
	end
end

function ConnectURL()
	gIsUrlConnected = true
	SetControlMethod()
end

function DisconnectURL()
	gIsUrlConnected = false
	SetControlMethod()
end
 end)
package.preload['common.c4_utils'] = (function (...)
--[[=============================================================================
    Helper functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_utils = "2016.01.08"
end

--[[=============================================================================
    AsciiToBCD(InString)

    Description
    Convert an ascii string to a binary coded decimal. Each decimal digit is
    stored in one byte, with the lower four bits encoding the digit in BCD form.

    Parameters
    InString(string) - Ascii string that is to be converted into bcd

    Returns
    The binary coded decimal
===============================================================================]]
function AsciiToBCD(InString)
	local WorkVal = 0
	local RetValStr = ""
	local DoingHighNybble = false
	local WorkStr = ((#InString % 2) == 0) and (InString) or ("0" .. InString)	-- make sure length is an even number

	for CharCount = 1, #WorkStr do
		local NumVal = tonumber(WorkStr:sub(CharCount, CharCount))

		WorkVal = bit.lshift(WorkVal, 4) + NumVal
		if (DoingHighNybble) then
			RetValStr = RetValStr .. string.char(WorkVal)
			WorkVal = 0
		end

		DoingHighNybble = (not DoingHighNybble)
	end

	return RetValStr
end

--[[=============================================================================
    BCDToAscii(InByte)

    Description
    Convert an BCD string to an ascii string.

    Parameters
    InByte(string) - Binary coded decimal that is to be converted into ascii

    Returns
    The ascii string
===============================================================================]]
function BCDToAscii(InByte)
	return tostring(bit.rshift(InByte, 4)) .. tostring(bit.band(InByte, 0x0F))
end

--[[=============================================================================
    MakeXMLNode(Tag, Value)

    Description
    Create an Xml element

    Parameters
    Tag(string)   - The Xml elements name
    Value(string) - The Xml elements value

    Returns
    The xml element created for the specified value
===============================================================================]]
function MakeXMLNode(Tag, Value)
	return "<" .. Tag .. ">" .. Value .. "</" .. Tag .. ">"
end

--[[=============================================================================
    MakeXMLAttrNode(Tag, Value, Attribute, AttrValue)

    Description
    Create an Xml element with an attribute

    Parameters
    Tag(string)       - The Xml elements name
    Value(string)     - The Xml elements value
    Attribute(string) - The attribute to be added to the Xml element
    AttrValue(string) - The value of the attribute to be added

    Returns
    The xml element created for the specified value
===============================================================================]]
function MakeXMLAttrNode(Tag, Value, Attribute, AttrValue)
    return "<" .. Tag .. " " .. Attribute .. "=\"" .. AttrValue .. "\">" .. Value .. "</" .. Tag .. ">"
end

--[[=============================================================================
    StringFromUnicode(UnicodeString)

    Description
    Convert a unicode string

    Parameters
    UnicodeString(string) - The unicode string to be converted to ascii

    Returns
    The ascii representation of the unicode string
===============================================================================]]
function StringFromUnicode(UnicodeString)
	local RetVal = ""

	-- extract every other byte from the unicode string
	for Index = 2, #UnicodeString, 2 do
		RetVal = RetVal .. string.sub(UnicodeString, Index, Index)
	end

	return RetVal
end

--[[=============================================================================
    StringSplit(s)

    Description
    Splits a string into multiple strings at an optionally specified delimiter
	If the delimiter is not specified, it will defalt to the space character

    Parameters
    s(string) - The string that is to be split into several strings
	d(string) - The delimiter to split the string on

    Returns
    A table of strings containing all the seperate values in the given string
===============================================================================]]
function StringSplit(s, d)
	local delim = (d ~= nil) and d or " "
	local result = {}

	if s == nil or s == "" then
		return result
	end

	for match in (s..delim):gmatch("(.-)"..delim) do
		table.insert(result, match)
	end

	return result
end

--[[=============================================================================
    toboolean(s)

    Description
    Returns a boolean representation of the given value

    Parameters
    val input value, may be of different types

    Returns
    The value true or false based on the given value
		If the value is of type string the return true if the first letter is "T" or "t" or if the string is "1"
		If the value is of type number the return true if the value is non-zero
		If the value is already a boolean, just return it.
===============================================================================]]
function toboolean(val)
	local rval = false;

	if type(val) == "string" and (string.lower(val) == 'true' or val == "1") then
		rval = true
	elseif type(val) == "number" and val ~= 0 then
		rval =  true
	elseif type(val) == "boolean" then
		rval = val
	end

	return rval
end

--[[=============================================================================
    tointeger(s)

    Description
    Force a number or a string representation of a number to be an integer

    Parameters
    val - A number or a string representation of a number

    Returns
    The the rounded off integer value.
===============================================================================]]
function tointeger(val)
	local nval = tonumber(val)
	return (nval >= 0) and math.floor(nval + 0.5) or math.ceil(nval - 0.5)
end


--[[=============================================================================
    Go(to, err, ...)

    Description
    Call a function with the given arguments if it exists or report the error

    Parameters
    to(string)  - The string to evaluate the boolean representation from
    err(string) - The error to report if the function does not exist
    ...         - Additional optional parameters for the function specified by
                  the "to" parameter

    Returns
    Nothing
===============================================================================]]
function Go(to, err, ...)
	if (type(to) == "function") then
		return to(...)
	else
		LogTrace(err)
	end
end

--[[=============================================================================
    IsEmpty(str)

    Description
    Identifies if the string given is nil or empty

    Parameters
    str(string) - The string to evaluate for the empty condition

    Returns
    True if the given value is empty, false otherwise
===============================================================================]]
function IsEmpty(str)
	return str == nil or str == ""
end

--[[=============================================================================
    ReverseTable(a)

    Description
    Reverse table entries (key=value, value=key)

    Parameters
    a(table) - The table to reverse

    Returns
    new reversed table
===============================================================================]]
function ReverseTable(a)
	local b = {}
	for k,v in pairs(a) do b[v] = k end
	return b
end

function tonumber_loc(str, base)
  local s = str:gsub(",", ".") -- Assume US Locale decimal separator
  local num = tonumber(s, base)
  if (num == nil) then
    s = str:gsub("%.", ",") -- Non-US Locale decimal separator
    num = tonumber(s, base)
  end
  return num
end

--[[=============================================================================
    HexToString(InString)

    Description
    Converts a string of Hex characters to a readable string of ASCII characters

    Parameters
    InString(string) - The string to be converted

    Returns
    A string showing the hex bytes of the InString
===============================================================================]]
function HexToString(InString)
	local RetVal = ""

	for Index = 1, #InString do
		RetVal = RetVal .. string.format("%02X ", InString:byte(Index))
	end
	return RetVal
end


--[[=============================================================================
    StringToHex(InString)

    Description
    Converts a string of ASCII characters to as string with the actual Hex bytes in them.
	Basically an array of hex bytes.

    Parameters
    InString(string) - The string to be converted

    Returns
    A string of hex bytes (really an array of hex values) 
===============================================================================]]
function StringToHex(InString)
	local RetVal = ""

	for HexByteString in string.gfind(InString, "%x%x") do
		RetVal = RetVal .. string.char(tonumber(HexByteString, 16))
	end
	return RetVal
end

function RecordHistory(severity, eventType, category, subcategory, description)
	C4:RecordHistory(severity, eventType, category, subcategory, description)
end

function RecordCriticalHistory(eventType, category, subcategory, description)
	RecordHistory("Critical", eventType, category, subcategory, description)
end

function RecordWarningHistory(eventType, category, subcategory, description)
	RecordHistory("Warning", eventType, category, subcategory, description)
end

function RecordInfoHistory(eventType, category, subcategory, description)
	RecordHistory("Info", eventType, category, subcategory, description)
end


 end)
package.preload['lib.c4_object'] = (function (...)
--[[=============================================================================
    c4_object Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_object = "2016.01.08"
end

function inheritsFrom( baseClass )
	local new_class = {}
	local class_mt = { __index = new_class }

	function new_class:create(...)
		local newinst = {}

		setmetatable( newinst, class_mt )

		-- Call the constructor when we create this class
		if newinst.construct then
			-- Allow returning a different obj than self. This allows for readonly tables etc...
			newinst = newinst:construct(...) or newinst
		end

		return newinst
	end

	if nil ~= baseClass then
		setmetatable( new_class, { __index = baseClass } )
	end

	--[[=============================================================================
	    Implementation of additional OO properties starts here 
	===============================================================================]]
	
	-- Return the class object of the instance
	function new_class:class()
		return new_class
	end

	--[[=============================================================================
	    Return the super class object of the instance. 

	    Note Calling methods on the base class itself will modify
	    the base table's static properties. In order to have call
	    the base class' methods and have them modify the current object
	    use super() or superAsSelf(). 
	===============================================================================]]
	function new_class:superClass()
		return baseClass
	end

	--[[=============================================================================
	    Returns a table that allows calling of the base class's method
	    while maintaining the objects state as the modified state of the base
	    class' methods. For example consider the following statements (order matters):

	    -- The child sees the parents property if the child hasn't overriden the property
	       obj:superClass().id = "parent"
	       obj.id == "parent" -- true

	    -- Setting the property on the child overrides (hides) the parents property
	       obj.id = "child"
	       obj.id == "child" -- true

	    -- The super() method pass
	       obj:super().id == "parent" -- true
	       obj:super().id = "child"
	       obj:super().id == "parent" -- still true
	       obj.id == "child" -- still true
	===============================================================================]]
	function new_class:super()
		local holder = {}

		holder.child = self
		holder.parent = baseClass

		local mt = {}
		mt.__index = function(table, index)
			if table.parent[index] then
				return table.parent[index]
			else 
				return table.child[index]
			end
		end

		-- Only set the new values to the child.
		mt.__newindex = function(table, key, value)
			table.child[key] = value
		end

		mt.__tostring = function(table)
			return tostring(table.child)
		end

		setmetatable(holder, mt)
		return holder
	end

	new_class.new = new_class.create

	--[[=============================================================================
	    Return true if the caller is an instance of theClass
	===============================================================================]]
	function new_class:isa( theClass )
		local b_isa = false
		local cur_class = new_class

		while ( nil ~= cur_class ) and ( false == b_isa ) do
			if cur_class == theClass then
				b_isa = true
			else
				cur_class = cur_class:superClass()
			end
		end

		return b_isa
	end

	return new_class
end

--[[=============================================================================
    Inheritance unit tests
===============================================================================]]
function __test_inheritance()
	local b = inheritsFrom(nil)

	b.construct = function(self, msg)
		self._msg = msg
	end

	local t = inheritsFrom(b)
	t.construct = function(self, msg)
		self:super():construct(msg)
	end

	t1 = t:new("t1")
	t2 = t:new("t2")
	assert(t1._msg == "t1", "t1 message is not equal to 't1' it''s: " .. t1._msg)
	assert(t2._msg == "t2", "t2 message is not equal to 't2' it''s: " .. t2._msg)    
	assert(tostring(t1:super()) ==  tostring(t1), "tostrings don't match");
	assert(t1:superClass() == b, "superClass and baseClass should be the same. They are not.")

	t1:superClass().id = "parent"
	assert(t1.id == "parent", "obect''s super class has invalid property value: ", t1.id)

	-- Setting the property on the child overrides (hides) the parents property
	t1.id = "child"
	assert(t1.id == "child", "object instance variable has invalid property value: " .. t1.id)

	-- The super() method maintains the self pointer to the child and not to the base
	assert(t1:super().id == "parent", "superAsSelf found invalid value for base class variable")
	t1:super().id = "child1"
	assert(t1:super().id == "parent", "Setting of instance variable hid base classes variable from itself");
	assert(t1.id == "child1", "Settings of instance variable did not change child instance variable")
end end)
package.preload['lib.c4_log'] = (function (...)
--[[=============================================================================
    c4_log Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_log = "2016.01.08"
end

c4_log = inheritsFrom(nil)

function c4_log:construct(logName)
	self._logLevel = tonumber(string.sub(Properties['Log Level'] or "", 1, 1)) or 5
	self._outputPrint = Properties['Log Mode']:find("Print") ~= nil
	self._outputC4Log = Properties['Log Mode']:find("Log") ~= nil
	self._logName = logName or ""

	-- make sure Property is up to date (no harm if absent)
	C4:UpdateProperty("Log Level", Properties['Log Level'])
end

function c4_log:SetLogLevel(level)
	self._logLevel = tonumber(string.sub(level or "", 1, 1)) or self._logLevel
end

function c4_log:LogLevel()
	return self._logLevel
end

function c4_log:OutputPrint(value)
	self._outputPrint = value
end

function c4_log:OutputC4Log(value)
	self._outputC4Log = value
end

function c4_log:SetLogName(logName)

	if (logName == nil or logName == "") then
		logName = ""
	else
		logName = logName .. ": "
	end

	self._logName = logName
end

function c4_log:LogName()
	return self._logName
end

function c4_log:Enabled()
	return (self._outputPrint or self._outputC4Log)
end

function c4_log:PrintEnabled()
	return self._outputPrint
end

function c4_log:C4LogEnabled()
	return self._outputC4Log
end

function c4_log:CreateTableText(tValue, tableText)
	tableText = tableText or ""

	if (type(tValue) == "table") then

		tableText = tableText .. "{"
		for k, v in pairs(tValue) do

			-- add key
			if (type(k) == "number") then
				tableText = tableText .. "[" .. tostring(k) .. "]="
			elseif (type(k) == "string") then
				tableText = tableText .. k .. "="
			else
				print (tostring(k) .. ": " .. tostring (v))
			end

			-- add value
			if (type(v) == "number") then
				tableText = tableText .. tostring(v) .. ","
			elseif (type(v) == "string") then
				tableText = tableText .. "'" .. v .. "',"
			elseif (type(v) == "table") then
				tableText = c4_log:CreateTableText(v, tableText)
				tableText = tableText .. ","
			elseif (type(v) == "boolean") then
				tableText = tableText .. tostring(v) .. ","
			end
		end

		tableText = tableText .. "}"
	end

	return tableText
end

function InsertIndent(indentLevel)
	local indentStr = ""

	for i=1, indentLevel do
		indentStr = indentStr .. "\t"
	end

	return indentStr
end

function c4_log:CreateTableTextFormatted(tValue, tableText, indentLevel)
	tableText = tableText or ""
	indentLevel = indentLevel or 0

	if (type(tValue) == "table") then

		indentLevel = indentLevel + 1
		tableText = tableText .. "{\n"
		for k, v in pairs(tValue) do

			-- add key
			if (type(k) == "number") then
				tableText = tableText .. InsertIndent(indentLevel) .. "[" .. tostring(k) .. "]="
			elseif (type(k) == "string") then
				tableText = tableText .. InsertIndent(indentLevel) .. k .. "="
			else
				print (tostring(k) .. ": " .. tostring (v))
			end

			-- add value
			if (type(v) == "number") then
				tableText = tableText .. tostring(v) .. ",\n"
			elseif (type(v) == "string") then
				tableText = tableText .. "'" .. v .. "',\n"
			elseif (type(v) == "table") then
				tableText = c4_log:CreateTableTextFormatted(v, tableText, indentLevel)
				tableText = tableText .. ",\n"
			elseif (type(v) == "boolean") then
				tableText = tableText .. tostring(v) .. ",\n"
			end
		end

		indentLevel = indentLevel - 1
		tableText = tableText .. InsertIndent(indentLevel) .. "}"
	end

	return tableText
end

MAX_TABLE_LEVELS = 10
function c4_log:PrintTable(tValue, tableText, sIndent, level)
	tableText = tableText or ""
	level = level + 1
	
	if (level <= MAX_TABLE_LEVELS) then
		if (type(tValue) == "table") then
			for k,v in pairs(tValue) do
				if (tableText == "") then
					tableText = sIndent .. tostring(k) .. ":  " .. tostring(v)
					if (sIndent == ".   ") then sIndent = "    " end
				else
					tableText = tableText .. "\n" .. sIndent .. tostring(k) .. ":  " .. tostring(v)
				end
				if (type(v) == "table") then
					tableText = self:PrintTable(v, tableText, sIndent .. "   ", level)
				end
			end
		else
			tableText = tableText .. "\n" .. sIndent .. tostring(tValue)
		end
	end
	
	return tableText
end

function c4_log:LogTable(tValue, sIndent, level)
	level = level + 1
	
	if (level <= MAX_TABLE_LEVELS) then
		if (type(tValue) == "table") then
			for k,v in pairs(tValue) do
				C4:ErrorLog(self._logName .. sIndent .. tostring(k) .. ":  " .. tostring(v))
				if (type(v) == "table") then
					self:LogTable(v, sIndent .. "   ", level)
				end
			end
		else
			C4:ErrorLog(self._logName .. sIndent .. tValue)
		end
	end
end

function c4_log:Print(logLevel, sLogText)

	if (self._logLevel >= logLevel) then
		if (type(sLogText) == "table") then
			if (self._outputPrint) then
				print (self:PrintTable(sLogText, tableText, ".   ", 0))
			end

			if (self._outputC4Log) then
				self:LogTable(sLogText, "   ", 0)
			end

			return
		end

		if (self._outputPrint) then
			print (sLogText)
		end

		if (self._outputC4Log) then
			C4:ErrorLog(self._logName .. tostring(sLogText))
		end
	end
end

function c4_log:Fatal(sLogText, ...)
	self:LogOutput(0, sLogText, ...)
end

function c4_log:Error(sLogText, ...)
	self:LogOutput(1, sLogText, ...)
end

function c4_log:Warn(sLogText, ...)
	self:LogOutput(2, sLogText, ...)
end

function c4_log:Info(sLogText, ...)
	self:LogOutput(3, sLogText, ...)
end

function c4_log:Debug(sLogText, ...)
	self:LogOutput(4, sLogText, ...)
end

function c4_log:Trace(sLogText, ...)
	self:LogOutput(5, sLogText, ...)
end

function c4_log:LogOutput(level, sLogText, ...)
	if (LogEnabled()) then
		if (type(sLogText) == "string") then
			sLogText = string.format(sLogText, ...)
		end

		self:Print(level, sLogText)
	end
end

--[[=============================================================================
    c4_log wrapper functions
===============================================================================]]
function TryLog(level, sLogText, ...)
	LOG:LogOutput(level, sLogText, ...)
end

--[[=============================================================================
    SetLogLevel(level)

    Description: 
    Sets the desired log level to view

    Parameters:
    level(int) - The logging level to set the message to
                 0 = Fatal
                 1 = Error
                 2 = Warn
                 3 = Info
                 4 = Debug
                 5 = Trace

    Returns:
    None
===============================================================================]]
function SetLogLevel(level)
	LOG:SetLogLevel(level)
end

--[[=============================================================================
    LogLevel()

    Description: 
    Returns the currently set log level

    Parameters:
    None

    Returns:
    The current log level
        0 = Fatal
        1 = Error
        2 = Warn
        3 = Info
        4 = Debug
        5 = Trace
===============================================================================]]
function LogLevel()
	return LOG:LogLevel()
end

--[[=============================================================================
    OutputPrint(value)

    Description: 
    Specifies whether to output log messages or not

    Parameters:
    value(bool) - true to enable logging output, false otherwise

    Returns:
    None
===============================================================================]]
function OutputPrint(value)
	LOG:OutputPrint(value)
end

--[[=============================================================================
    OutputPrint(value)

    Description: 
    Specifies whether to output log messages to file or not

    Parameters:
    value(bool) - true to enable logging output, false otherwise

    Returns:
    None
===============================================================================]]
function OutputC4Log(value)
	LOG:OutputC4Log(value)
end

--[[=============================================================================
    SetLogName(logName)

    Description: 
    Sets the name of the log file where the messages will be written to

    Parameters:
    logName(string) - Sets the name of the log to write messages to

    Returns:
    None
===============================================================================]]
function SetLogName(logName)
	LOG:SetLogName(logName)
end

--[[=============================================================================
    LogName(logName)

    Description: 
    Gets the name of the log file where the messages will be written to

    Parameters:
    None

    Returns:
    The value of the log file that has been set
===============================================================================]]
function LogName()
	return LOG:LogName()
end

--[[=============================================================================
    LogEnabled()

    Description: 
    Identifies if logging or print has been enabled

    Parameters:
    None

    Returns:
    true if either logging or print has been enabled, false otherwise
===============================================================================]]
function LogEnabled()
	return LOG:Enabled()
end

--[[=============================================================================
    PrintEnabled()

    Description: 
    Gets the state of print output

    Parameters:
    None

    Returns:
    true if print has been enabled, false otherwise
===============================================================================]]
function PrintEnabled()
	return LOG:PrintEnabled()
end

--[[=============================================================================
    C4LogEnabled()

    Description: 
    Gets the state of logging

    Parameters:
    None

    Returns:
    true if logging has been enabled, false otherwise
===============================================================================]]
function C4LogEnabled()
	return LOG:C4LogEnabled()
end

--[[=============================================================================
    LogFatal(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Fatal(0) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogFatal(sLogText, ...)
	local status, err = pcall(TryLog, 0, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogFatal failed: " .. err)
	end
end

--[[=============================================================================
    LogError(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Error(1) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogError(sLogText, ...)
	local status, err = pcall(TryLog, 1, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogError failed: " .. err)
	end
end

--[[=============================================================================
    LogWarn(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Warn(2) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogWarn(sLogText, ...)
	local status, err = pcall(TryLog, 2, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogWarn failed: " .. err)
	end
end

--[[=============================================================================
    LogInfo(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Info(3) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogInfo(sLogText, ...)
	local status, err = pcall(TryLog, 3, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogInfo failed: " .. err)
	end
end

--[[=============================================================================
    LogDebug(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Debug(4) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogDebug(sLogText, ...)
	local status, err = pcall(TryLog, 4, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogDebug failed: " .. err)
	end
end

--[[=============================================================================
    LogTrace(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Trace(5) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogTrace(sLogText, ...)
	local status, err = pcall(TryLog, 5, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogTrace failed: " .. err)
	end
end

function dbgPrint(buf)
	if (LOG:PrintEnabled()) then
		print (buf)
	end
end

function dbgHexdump(buf)
	hexdump(buf, dbgPrint)
end

--[[=============================================================================
    c4_log unit tests
===============================================================================]]
function __test_c4_log()
	require "test.C4Virtual"
	
	local LOG = c4_log:new("test_c4_log")
	assert(LOG:LogName() == "test_c4_log", "_logName is not equal to 'test_c4_log' it is: " .. LOG:LogName())

	-- Test setting log level
	LOG:SetLogLevel("2 - Warning")
	assert(LOG:LogLevel() == 2, "_logLevel is not equal to '2' it is: " .. LOG:LogLevel())

	LOG:SetLogLevel(3)
	assert(LOG:LogLevel() == 3, "_logLevel is not equal to '3' it is: " .. LOG:LogLevel())

	-- Test enabling logs
	LOG:OutputPrint(false)
	assert(LOG:PrintEnabled() == false, "_outputPrint is not equal to 'false' it is: " .. tostring(LOG:PrintEnabled()))

	LOG:OutputC4Log(true)
	assert(LOG:C4LogEnabled() == true, "_outputC4Log is not equal to 'true' it is: " .. tostring(LOG:C4LogEnabled()))

	LOG:SetLogLevel(4)
	LogTrace("***** This is a test *****")
end

function __test_CreatTableText()
	local tTest = {}

	tTest[1] = {}
	tTest[2] = {}
	tTest[3] = 30
	tTest[4] = "Forty"
	
	LogTrace("----- tText -----")
	LogTrace(tTest)

	local tTest2 = { One = {},
					 Two = {},
					 Three = 30,
					 Four = "Forty" }
	LogTrace("----- tText2 -----")
	LogTrace(tTest2)
	
	local tTest3 = { [1] = {},
					 [2] = {},
					 [3] = 30,
					 [4] = "Forty" }
	LogTrace("----- tText3 -----")
	LogTrace(tTest3)

	local tTest4 = { [1] = {},
					 Two = {},
					 [3] = 30,
					 [4] = "Forty",
					 Five = "Fifty" }
	LogTrace("----- tText4 -----")
	LogTrace(tTest4)

	local tableText = LOG:CreateTableText(tTest4)
	LogTrace("----- tableText -----")
	LogTrace(tableText)
	
	--local tNew = {[1] = {},[3] = 30,[4] = 'Forty',Five = 'Fifty',Two = {},}
	--LogTrace(tNew)
end

function __TestCreateTableTextFormatted()
	require "test.C4Virtual"
	
	local LOG = c4_log:new("test_c4_log")
	local tButtons = {
		Name = 'heat',
		Attributes = {},
		ChildNodes = {
			[1] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '51',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {
						Value = 'Pool Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {},
					},
					[3] = {
						Value = 'POOLHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				},
			},
			[2] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '53',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {
						Value = 'Spa Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {},
					},
					[3] = {
						Value = 'SPAHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				},
			},
			[3] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '54',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {Value = 'Pool Solar Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {}
					},
					[3] = {
						Value = 'SOLHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				}
			}
		}
	}

	print(LOG:CreateTableTextFormatted(tButtons))
end end)
package.preload['lib.c4_timer'] = (function (...)
--[[=============================================================================
    c4_timer Class

    Copyright 2017 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_timer = "2017.05.03"
end

c4_timer = inheritsFrom(nil)

function c4_timer:construct(name, interval, units, Callback, repeating, CallbackParam)
	self._name = name
	self._timerID = TimerLibGetNextTimerID()
	self._interval = interval
	self._units = units
	self._repeating = repeating or false
	self._Callback = Callback
	self._CallbackParam = CallbackParam or ""
	self._id = 0

	gTimerLibTimers[self._timerID] = self
	if (LOG ~= nil and type(LOG) == "table") then
		LogTrace("Created timer " .. self._name)
	end
end

function c4_timer:StartTimer(...)
	c4_timer:KillTimer()

	-- optional parameters (interval, units, repeating)
	if ... then
		local interval = select(1, ...)
		local units = select(2, ...)
		local repeating = select(3, ...)

		self._interval = interval or self._interval
		self._units = units or self._units
		self._repeating = repeating or self._repeating
	end

	if (tonumber(self._interval) > 0) then
		if (LOG ~= nil and type(LOG) == "table") then
			LogTrace("Starting Timer: " .. self._name)
		end

		self._id = C4:AddTimer(self._interval, self._units, self._repeating)
	end
end

function c4_timer:KillTimer()
	if (self._id) then
		self._id = C4:KillTimer(self._id)
	end
end

function c4_timer:TimerStarted()
	return (self._id ~= 0)
end

function c4_timer:TimerStopped()
	return (self._id == 0)
end

function c4_timer:GetTimerInterval()
	return (self._interval)
end

function TimerLibGetNextTimerID()
	gTimerLibTimerCurID = gTimerLibTimerCurID + 1
	return gTimerLibTimerCurID
end

function ON_DRIVER_EARLY_INIT.c4_timer()
	gTimerLibTimers = {}
	gTimerLibTimerCurID = 0
end

function ON_DRIVER_DESTROYED.c4_timer()
	-- Kill open timers
	for k,v in pairs(gTimerLibTimers) do
		v:KillTimer()
	end
end

--[[=============================================================================
    OnTimerExpired(idTimer)

    Description:
    Function called by Director when the specified Control4 timer expires.

    Parameters:
    idTimer(string) - Timer ID of expired timer.
===============================================================================]]
function OnTimerExpired(idTimer)
	for k,v in pairs(gTimerLibTimers) do
		if (idTimer == v._id) then
			if (v._Callback) then
				v._Callback(v._CallbackParam)
			end
		end
	end
end

--[[=============================================================================
    CreateTimer(name, interval, units, callback, repeating, callbackParam)

    Description: 
    Creates a named timer with the given attributes

    Parameters:
    name(string)       - The name of the timer being created
    interval(int)      - The amount of the given time between calls to the
                         timers callback function
    units(string)      - The time of time interval used (e.g. MILLSECONDS, SECONDS, MINUTES, HOURS)
    callback(string)   - The function to call when the timer expires
    repeating(bool)    - Parameter indicating whether the timer should be
                         called repeatedly until cancelled
    callbackParam(...) - Parameters to be passed to the callback function

    Returns:
    A handle to the timer
===============================================================================]]
function CreateTimer(name, interval, units, callback, repeating, callbackParam)
	timer = c4_timer:new(name, interval, units, callback, repeating, callbackParam)
	return timer
end

--[[=============================================================================
    StartTimer(handle, ...)

    Description: 
    Starts the timer created by calling the CreateTimer functions

    Parameters:
    handle(timer)   - Handle to a created timer object
    interval(int)   - The amount of the given time between calls to the
                      timers callback function
    units(string)   - The time of time interval used (e.g. SECONDS, MINUTES, ...)
    repeating(bool) - Parameter indicating whether the timer should be
                      called repeatedly until cancelled

    Returns:
    None
===============================================================================]]
function StartTimer(handle, ...)
	handle:StartTimer(...)
end

--[[=============================================================================
    KillTimer(handle)

    Description: 
    Starts the timer created by calling the CreateTimer functions

    Parameters:
    handle(timer) - Handle to a created timer object

    Returns:
    None
===============================================================================]]
function KillTimer(handle)
	handle:KillTimer()
end

--[[=============================================================================
    TimerStarted(handle)

    Description: 
    Identifies whether a timer has been started or not

    Parameters:
    handle(timer) - Handle to a created timer object

    Returns:
    Returns true if a the given timer handle has been started, or false otherwise
===============================================================================]]
function TimerStarted(handle)
	return handle:TimerStarted()
end

--[[=============================================================================
    TimerStopped(handle)

    Description: 
    Identifies whether a timer has been stopped or not

    Parameters:
    handle(timer) - Handle to a created timer object

    Returns:
    Returns true if a the given timer handle has been stopped, or false otherwise
===============================================================================]]
function TimerStopped(handle)
	return handle:TimerStopped()
end

--[[=============================================================================
    GetTimerInterval(handle)

    Description: 
    Gets the interval setting of the given timer

    Parameters:
    handle(timer) - Handle to a created timer object

    Returns:
    Returns the interval setting of the given timer
===============================================================================]]
function GetTimerInterval(handle)
	return handle:GetTimerInterval()
end

--[[=============================================================================
    c4_timer Unit Tests
===============================================================================]]
function __test_c4_timer()
	require "test.C4Virtual"
	require "lib.c4_log"
	require "common.c4_init"

	OnDriverInit()

	local LOG = c4_log:new("test_c4_timer")
	LOG:SetLogLevel(5)
	LOG:OutputPrint(true)

	function OnTestTimerExpired()
		c4Timer:KillTimer()
	end

	-- create an instance of the timer
	c4Timer = c4_timer:new("Test", 45, "MINUTES", OnTestTimerExpired)

	assert(c4Timer._id == 0, "_id is not equal to '0' it is: " .. c4Timer._id)
	c4Timer:StartTimer()
	assert(c4Timer._id == 10001, "_id is not equal to '10001' it is: " .. c4Timer._id)
	assert(c4Timer:TimerStarted() == true, "TimerStarted is not equal to true it is: " .. tostring(c4Timer:TimerStarted()))
	assert(c4Timer:TimerStopped() == false, "TimerStopped is not equal to false it is: " .. tostring(c4Timer:TimerStopped()))
	OnTimerExpired(c4Timer._id)
	assert(c4Timer:TimerStarted() == false, "TimerStarted is not equal to false it is: " .. tostring(c4Timer:TimerStarted()))
	assert(c4Timer:TimerStopped() == true, "TimerStopped is not equal to true it is: " .. tostring(c4Timer:TimerStopped()))
end end)
package.preload['lib.c4_queue'] = (function (...)
--[[=============================================================================
    c4_queue Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_queue = "2016.01.08"
end

c4_queue = inheritsFrom(nil)

function c4_queue:construct()
	-- entry table
	self._et = {first = 0, last = -1}
	self._maxSize = 0	-- no size limit
	self._name = ""

	local mt = getmetatable(self)
	if (mt ~= nil) then
		mt.__tostring = self.__tostring
	end
end

function c4_queue:__tostring()
	local tOutputString = {}
	table.insert(tOutputString, "--- Queue ---")
	if (not IsEmpty(self._name)) then
		table.insert(tOutputString, "  name = " .. tostring(self._name))
	end
	table.insert(tOutputString, "  first = " .. tostring(self._et.first))
	table.insert(tOutputString, "  last = " .. tostring(self._et.last))
	table.insert(tOutputString, "  number in queue = " .. tostring(self._et.last - self._et.first + 1))
	table.insert(tOutputString, "  maximum size = " .. self._maxSize)
	table.insert(tOutputString, "  next value = " .. tostring(self:value()))
	return table.concat(tOutputString, "\n")
end


-- push a value on the queue
function c4_queue:push(value, ...)
	local numItems = self._et.last - self._et.first + 1

	if ((self._maxSize <= 0) or (numItems < self._maxSize) ) then
		local last = self._et.last + 1
		self._et.last = last
		
		local interval = select(1, ...)
		local units = select(2, ...)
		local command_name = select(3, ...)
		self._et[last] = {["command"] = value, ["command_delay"] = interval, ["delay_units"] = units, ["command_name"] = command_name}		
		--LogTrace ("Queue:push(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)
	else
		-- if addToQueue == true then push value to queue
		if (self:OnMaxSizeReached()) then
			local last = self._et.last + 1
			self._et.last = last
			self._et[last] = {["command"] = value, ["command_delay"] = interval, ["delay_units"] = units, ["command_name"] = command_name}
			--LogTrace ("Queue:push(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)
		end
	end
end

function c4_queue:OnMaxSizeReached()
	--LogTrace ("Max Size Reached - clear queue and push value to the queue (default).")
	local addToQueue = true

	self:clear()
	return (addToQueue)
end

-- pop a value from the queue
function c4_queue:pop()
	local first = self._et.first

	if first > self._et.last then
		--LogTrace("Queue:pop(), queue is empty")
		return ""
	end

	local value = self._et[first]
	self._et[first] = nil        -- to allow garbage collection
	self._et.first = first + 1
	--LogTrace ("Queue:pop(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)

	return value
end

-- clear queue
function c4_queue:clear()
	local first = self._et.first

	if first > self._et.last then
		--LogTrace ("Queue:clear(), queue is empty")
		return ""
	end

	self._et = {first = 0, last = -1}
	--LogTrace ("Queue:clear(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1))
	--LogTrace (self._et)
end

-- return value of first item
function c4_queue:value()
	local first = self._et.first

	if (first > self._et.last) then
		return ""
	else
		return self._et[first]
	end
end

-- return queue's maximum size
function c4_queue:MaxSize()
	return self._maxSize
end

-- return queue's maximum size
function c4_queue:SetMaxSize(size)
	self._maxSize = size
end

function c4_queue:SetName(name)
	self._name = name
end

-- return the queue's current size
function c4_queue:Size()
	return self._et.last - self._et.first + 1
end

-- is queue empty?
function c4_queue:empty()
	-- print ("self._et.first = " .. tostring(self._et.first) .. ", self._et.last = " .. tostring(self._et.last))
	if (self._et.first > self._et.last) then
		return true
	else
		return false
	end
end

--[[
    c4_queue unit tests
--]]
function __test_c4_queue()
	require "test.C4Virtual"
	require "lib.c4_log"

	local LOG = c4_log:new("test_c4_queue")
	LOG:SetLogLevel(5)
	LOG:OutputPrint(true)

	-- create an instance of the queue
	local c4Queue = c4_queue:new()

	c4Queue:SetMaxSize(3)
	assert(c4Queue:MaxSize() == 3, "_maxSize is not equal to '3' it is: " .. c4Queue:MaxSize())

	c4Queue:push("Item #1 in Queue")
	c4Queue:push("Item #2 in Queue")
	c4Queue:push("Item #3 in Queue")
	c4Queue:push("Item #4 in Queue")  -- this should cause OnMaxSizeReached() to be called and clear the queue
	assert(c4Queue:Size() == 1, "queue size is not equal to '1' it is: " .. c4Queue:Size())

	print (c4Queue)

	-- Test inheritance overriding OnMaxSizeReached
	-- Create a new class
	c4_queue_new = inheritsFrom(c4_queue)

	-- override construct()
	function c4_queue_new:construct()
		self.superClass():construct()  -- call base class
		self._maxSizeOption = 1

		local mt = getmetatable(self)
		if (mt ~= nil) then
			mt.__tostring = self.__tostring
		end
	end

	-- override OnMaxSizeReached()
	function c4_queue_new:OnMaxSizeReached()
		--Default: clear queue and push value to the queue. (No need to overload,

		-- Option 1: Do Nothing, new item is not added to queue
		if (self._maxSizeOption == 1) then
			
			LogInfo("Max Size Reached - do nothing, new item not added to queue (option 1)")
			return (false)
		-- Option 2: pop value, and push new value on queue
		elseif(self._maxSizeOption == 2) then
			LogInfo("Max Size Reached - pop value, and push new value on queue (option 2)")
			self:pop()
			return (true)
		-- Option 3: clear queue and DO NOT push new value onto queue
		elseif(self._maxSizeOption == 3) then
			LogInfo("Max Size Reached - clear queue and DO NOT push new value onto queue")
			self:clear()
			return (false)
		end
	end

	-- create an instance of the new queue
	local c4QueueNew = c4_queue_new:new()
	c4QueueNew:SetMaxSize(3)
	c4QueueNew:push("Item #1 in Queue")
	c4QueueNew:push("Item #2 in Queue")
	c4QueueNew:push("Item #3 in Queue")
	c4QueueNew:push("Item #4 in Queue")  -- this should cause OnMaxSizeReached() to be called and clear the queue
	assert(c4QueueNew:Size() == 3, "queue size is not equal to '3' it is: " .. c4QueueNew:Size())

	print(c4QueueNew)
	print ("done...")
end end)
package.preload['actions'] = (function (...)
--[[=============================================================================
    Lua Action Code

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.actions = "2016.01.08"
end

-- TODO: Create a function for each action defined in the driver

function LUA_ACTION.TemplateVersion()
	TemplateVersion()
end


function LUA_ACTION.PrintVolumeCurve()
    print("===== Volume Curve =====")
    for j,k in pairs(tVolumeCurve) do
	   print(j,k)
    end
end

function LUA_ACTION.SendToTCP(tParams)
	print("send to tcp")
	for cmd,cmdv in pairs(tParams) do
	   if(cmd == "MSG" and cmdv ~= nil) then
		  gCon:SendCommand(cmdv,1,"SECONDS","normal")
		  break
	   end
     end
	
end

function LUA_ACTION.Sync(tParams)
    print("sync device")
    IP_DEVICES_ADDR.init()
end
 end)
package.preload['lib.c4_xml'] = (function (...)
--[[=============================================================================
    Functions for parsing and managing xml

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_xml = "2016.01.08"
end

--[[=============================================================================
    GetParsedXmlNode(tXml, node)

    Description: 
    Find the specified node within the given table

    Parameters:
    tXml(table)  - Xml fragment containing the node we are looking for
    node(string) - The name of the node

    Returns:
    nil or the specified node within the table
===============================================================================]]
function GetParsedXmlNode(tXml, node)
	for k, v in pairs(tXml["ChildNodes"]) do
		if (v["Name"] == node) then
			return v["ChildNodes"]
		end
	end

	return nil
end

--[[=============================================================================
    GetParsedXmlValuesByKey(tXml, node, key, keyIsNumber)

    Description: 
    Find the specified node element within the given table

    Parameters:
    tXml(table)       - Xml fragment to find the value in
    node(string)      - The name of the node
    key(string)       - The name of the key
    keyIsNumber(bool) - Indicates whether the table index is a number or a string

    Returns:
    nil or a table of the found values within the Xml
===============================================================================]]
function GetParsedXmlValuesByKey(tXml, node, key, keyIsNumber)
	local tParams = {}

	keyIsNumber = keyIsNumber or false
	for k,v in pairs(tXml) do
		if (v["Name"] == node) then
			local keyValue
			
			-- get the key
			for nodeKey, nodeValue in pairs(v["ChildNodes"]) do
				if (nodeValue["Name"] == key) then
					if (keyIsNumber == true) then
						keyValue = tonumber(nodeValue.Value)
					else
						keyValue = tostring(nodeValue.Value)
					end
					break
				end
			end

			-- get other tags
			tParams[keyValue] = {}
			for nodeKey, nodeValue in pairs(v["ChildNodes"]) do
				if (nodeValue["Name"] ~= key) then
					tParams[keyValue][nodeValue.Name] = nodeValue.Value
				end
			end
		end
	end

	return tParams
end

--[[=============================================================================
    GetParsedXmlVaulesByKeyAttribute(tXml, node, key, keyIsNumber)

    Description: 
    Find the specified node attribute within the given table

    Parameters:
    tXml(table)       - Xml fragment to find the value in
    node(string)      - The name of the node
    key(string)       - The name of the key
    keyIsNumber(bool) - Indicates whether the table index is a number or a string

    Returns:
    nil or a table of the found values within the Xml
===============================================================================]]
function GetParsedXmlVaulesByKeyAttribute(tXml, node, key, keyIsNumber)
	local tParams = {}

	keyIsNumber = keyIsNumber or false
	for k,v in pairs(tXml["ChildNodes"]) do
		if (v["Name"] == node) then
			local keyValue

			if (keyIsNumber == true) then
				keyValue = tonumber(v["Attributes"][key])
			else
				keyValue = v["Attributes"][key]
			end
			
			tParams[keyValue] = v["Value"]
		end
	end

	return tParams
end

--[[=============================================================================
    BuildSimpleXml(tag, tData, escapeValue)

    Description: 
    Find the specified node within the given table

    Parameters:
    tag(string)       - Xml tag name to create
    tData(table)      - key value pairs that will be added as elements under tag
    escapeValue(bool) - Indicates whether the values should be escaped or not

    Returns:
    nil or an Xml fragment the specified node within the table
===============================================================================]]
function BuildSimpleXml(tag, tData, escapeValue)
	local xml = ""
	
	if (tag ~= nil) then
		xml = "<" .. tag .. ">"
	end
	
	for k,v in pairs(tData) do
		xml = xml .. "<" .. k
		if (type(v) == "table") then
			-- handle attributes
			for kAttrib, vAttrib in pairs(v.attributes) do
				xml = xml .. ' ' .. kAttrib .. '=\"' .. vAttrib .. '\"'
			end
			xml = xml .. ">" .. InsertValue(v.value, escapeValue) .. "</" .. k .. ">"
		else
			xml = xml .. ">" .. InsertValue(v, escapeValue) .. "</" .. k .. ">"
		end
	end
	
	if (tag ~= nil) then
		xml = xml .. "</" .. tag .. ">"
	end

	--DbgTrace("BuildSimpleXml(): " .. xml)

	return xml
end

--[[=============================================================================
    InsertValue(value, escapeValue)

    Description: 
    Return the given value if escapeValue is true it will escape any special
    characters in the value

    Parameters:
    value(string)     - value to be manipulated
    escapeValue(bool) - Indicates whether the values should be escaped or not

    Returns:
    The value given or an escaped value if specified
===============================================================================]]
function InsertValue(value, escapeValue)

	if (escapeValue) then
		value = C4:XmlEscapeString(tostring(value))
	end

	return value
end

--[[=============================================================================
    StartElement(tag)

    Description: 
    Wrap the given tag as an Xml element (i.e. <tag>)

    Parameters:
    tag(string) - The name of the item to be wrapped as a starting Xml element

    Returns:
    The value wrapped as Xml tag
===============================================================================]]
function StartElement(tag)
	return "<" .. tag .. ">"
end

--[[=============================================================================
    EndElement(tag)

    Description: 
    Wrap the given tag as an Xml end element (i.e. </tag>)

    Parameters:
    tag(string) - The name of the item to be wrapped as a ending Xml element

    Returns:
    The value wrapped as ending Xml tag
===============================================================================]]
function EndElement(tag)
	return "</" .. tag .. ">"
end

--[[=============================================================================
    AddElement(tag, data)

    Description: 
    Wrap the given tag and value as an Xml element (i.e. <tag>data</tag>)

    Parameters:
    tag(string)  - The name of the item to be wrapped as an Xml element
    data(string) - The value of the Xml element being created

    Returns:
    The value wrapped as Xml tag and value
===============================================================================]]
function AddElement(tag, data)
	LogTrace("tag = " .. tag)
	LogTrace("data = " .. data)
	
	return "<" .. tag .. ">" .. data .. "</" .. tag .. ">"
end
 end)
package.preload['connections'] = (function (...)
--[[=============================================================================
    Functions for managing the status of the drivers bindings and connection state
 
    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_network_connection"
require "common.c4_serial_connection"
require "common.c4_ir_connection"
require "common.c4_url_connection"

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.connections = "2016.08.15"
end

-- constants
COM_USE_ACK = false
COM_COMMAND_DELAY_MILLISECONDS = 250
COM_COMMAND_RESPONSE_TIMEOUT_SECONDS = 4

NETWORK_PORT = 60000
IR_BINDING_ID = 2
SERIAL_BINDING_ID = 1
NETWORK_BINDING_ID = 6001

--[[=============================================================================
    OnSerialConnectionChanged(idBinding, class, bIsBound)
  
    Description:
    Function called when a serial binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed (SERIAL_BINDING_ID).
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnSerialConnectionChanged(idBinding, class, bIsBound)
	
end

--[[=============================================================================
    OnIRConnectionChanged(idBinding, class, bIsBound)
  
    Description:
    Function called when an IR binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed (SERIAL_BINDING_ID).
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnIRConnectionChanged(idBinding, class, bIsBound)
	
end

--[[=============================================================================
    OnNetworkConnectionChanged(idBinding, bIsBound)
  
    Description:
    Function called when a network binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnNetworkConnectionChanged(idBinding, bIsBound)
	
end

--[[=============================================================================
    OnNetworkStatusChanged(idBinding, nPort, sStatus)
  
    Description:
    Called when the network connection status changes. Sets the updated status of the specified binding
  
    Parameters:
    idBinding(int)  - ID of the binding whose status has changed
    nPort(int)      - The communication port of the specified bindings connection
    sStatus(string) - "ONLINE" if the connection status is to be set to Online,
                      any other value will set the status to Offline
  
    Returns:
    None
===============================================================================]]
function OnNetworkStatusChanged(idBinding, nPort, sStatus)
	
end

--[[=============================================================================
    OnServerConnectionStatusChanged(nHandle, nPort, strStatus)
  
    Description:
    Called when the network server connection status changes. Sets the updated status of the specified binding
  
    Parameters:
    nHandle(int)  	- Handle of the connection whose status has changed
    nPort(int)      - The communication port of the specified bindings connection
    sStatus(string) - "ONLINE" if the connection status is to be set to Online,
                      any other value will set the status to Offline
  
    Returns:
    None
===============================================================================]]
function OnServerConnectionStatusChanged(nHandle, nPort, strStatus)
--	if (strStatus == "ONLINE") then
--		LogTrace("Server Connection Established: %s", tostring(nHandle))
--	else
--		LogTrace("Server Connection Disconnected: %s", tostring(nHandle))
--	end
end

--[[=============================================================================
    OnURLConnectionChanged(url)
  
    Description:
    Function called when the c4_url_connection is created.
  
    Parameters:
    url - url used by the url connection.
  
    Returns:
    None
===============================================================================]]
function OnURLConnectionChanged(url)
	
end

--[[=============================================================================
    DoEvents()
  
    Description:
    
  
    Parameters:
    None
  
    Returns:
    None
===============================================================================]]
function DoEvents()
end

--[[=============================================================================
    SendKeepAlivePollingCommand()
  
    Description:
    Sends a driver specific polling command to the connected system
  
    Parameters:
    None
  
    Returns:
    None
===============================================================================]]
function SendKeepAlivePollingCommand()
	--TODO: Implement the keep alive command for the network connected system if required.
end

 end)
package.preload['properties'] = (function (...)
--[[=============================================================================
    Properties Code

    Copyright 2017 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.properties = "2017.01.13"
end

--[[
function ON_PROPERTY_CHANGED.MJPEGStreamID(propertyValue)
	gCameraProxy._MJPEG_Stream_ID = tonumber(propertyValue)
end

function ON_PROPERTY_CHANGED.MJPEGStreamProfile(propertyValue)
	gCameraProxy._MJPEG_Stream_Profile = propertyValue
end

function ON_PROPERTY_CHANGED.H264StreamID(propertyValue)
	gCameraProxy._H264_Stream_ID = tonumber(propertyValue)
end

function ON_PROPERTY_CHANGED.H264720pStreamID(propertyValue)
	gCameraProxy._H264_720p_Stream_ID = tonumber(propertyValue)
end

function ON_PROPERTY_CHANGED.H2641080pStreamID(propertyValue)
	gCameraProxy._H264_1080p_Stream_ID = tonumber(propertyValue)
end

function ON_PROPERTY_CHANGED.H2644KStreamID(propertyValue)
	gCameraProxy._H264_4K_Stream_ID = tonumber(propertyValue)
end

function ON_PROPERTY_CHANGED.H264StreamProfile(propertyValue)
	gCameraProxy._H264_Stream_Profile = propertyValue
end

function ON_PROPERTY_CHANGED.H264720pStreamProfile(propertyValue)
	gCameraProxy._H264_720p_Stream_Profile = propertyValue
end

function ON_PROPERTY_CHANGED.H2641080pStreamProfile(propertyValue)
	gCameraProxy._H264_1080p_Stream_Profile = propertyValue
end

function ON_PROPERTY_CHANGED.H2644KStreamProfile(propertyValue)
	gCameraProxy._H264_4K_Stream_Profile = propertyValue
end
]] end)
package.preload['device_messages'] = (function (...)
--[[=============================================================================
    Get, Handle and Dispatch message functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.device_messages = "2016.01.08"
end

--[[=============================================================================
    GetMessage()
  
    Description:
    Used to retrieve a message from the communication buffer. Each driver is
    responsible for parsing that communication from the buffer.
  
    Parameters:
    None
  
    Returns:
    A single message from the communication buffer
===============================================================================]]
function GetMessage()
	local message = ""
	
	if ((gReceiveBuffer ~= nil) and (gReceiveBuffer ~= "")) then

		--TODO: Implement a routine which will parse out a single message
		--      from the receive buffer(gReceiveBuffer)
		message = gReceiveBuffer
	end

	--TODO: Once a complete message is found in the buffer remove it and 
	--      return the message
	gReceiveBuffer = ""

	return message
end

--[[=============================================================================
    HandleMessage(message)]

    Description
    This is where we parse the messages returned from the GetMessage()
    function into a command and data. The call to 'DispatchMessage' will use the
    'name' variable as a key to determine which handler routine, function, should
    be called in the DEV_MSG table. The 'value' variable will then be passed as
    a string parameter to that routine.

    Parameters
    message - Message string containing the function and value to be sent to DispatchMessage

    Returns
    Nothing
===============================================================================]]
function HandleMessage(message)
	if (type(message) == "table") then
		LogTrace("HandleMessage. Message is ==>")
		LogTrace(message)
		LogTrace("<==")
	else
		LogTrace("HandleMessage. Message is ==>%s<==", message)
		if(#DEVICE_ADDR > 0) 
	     then
		  if(string.char(string.byte(message)) == "0") 
		  then
			 print("send to devaddr 0")
			 C4:SendToDevice(DEVICE_ADDR[0],"OFF",{})
		  elseif(string.char(string.byte(message)) == "1") 
		  then
			 print("send to devaddr 1")
			 C4:SendToDevice(DEVICE_ADDR[1],"ON",{})
		  elseif(string.char(string.byte(message)) == "2") 
		  then
			 print("send to devaddr 2")
			 C4:SendToDevice(DEVICE_ADDR[1],"OFF",{})
		  elseif(string.char(string.byte(message)) == "3") 
		  then
			 print("send to devaddr 3")
			 C4:SendToDevice(DEVICE_ADDR[0],"ON",{})
		  else
		  end
		end
	end

	-- TODO: Parse messages and DispatchMessage

	--DispatchMessage(name, value)
end

--[[=============================================================================
    DispatchMessage(MsgKey, MsgData)

    Description
    Parse routine that will call the routines to handle the information returned
    by the connected system.

    Parameters
    MsgKey(string)  - The function to be called from within DispatchMessage
    MsgData(string) - The parameters to be passed to the function found in MsgKey

    Returns
    Nothing
===============================================================================]]
function DispatchMessage(MsgKey, MsgData)
	if (DEV_MSG[MsgKey] ~= nil and (type(DEV_MSG[MsgKey]) == "function")) then
		LogInfo("DEV_MSG.%s:  %s", MsgKey, MsgData)
		local status, err = pcall(DEV_MSG[MsgKey], MsgData)
		if (not status) then
			LogError("LUA_ERROR: %s", err)
		end
	else
		LogTrace("HandleMessage: Unhandled command = %s", MsgKey)
	end
end
 end)
package.preload['device_specific_commands'] = (function (...)
--[[=============================================================================
    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.device_specific_commands = "2016.01.08"
end

--[[=============================================================================
    ExecuteCommand Code

    Define any functions for device specific commands (EX_CMD.<command>)
    received from ExecuteCommand that need to be handled by the driver.
===============================================================================]]
--function EX_CMD.NEW_COMMAND(tParams)
--	LogTrace("EX_CMD.NEW_COMMAND")
--	LogTrace(tParams)
--end

function EX_CMD.SENDDEV(tParams)
	LogTrace("EX_CMD.SENDDEV")
	LogTrace(tParams)
	gCon:SendCommand("HELLO WORLD",1,"SECONDS","normal")
end end)
package.preload['keypad.keypad_proxy_class'] = (function (...)
--[[=============================================================================
    Keypad Proxy Class

    Copyright 2018 Hiwise Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.keypad_proxy_class = "2018.05.23"
end

KeypadProxy = inheritsFrom(nil)

function KeypadProxy:construct(bindingID)
	-- member variables
	self._BindingID = bindingID

	self:Initialize()

end

function KeypadProxy:Initialize()
	-- create and initialize member variables

end

function KeypadProxy:dev_Newbuttoncreate(buttonid,buttonname)
	local new_button = {}
     new_button.BUTTON_ID = buttonid
	new_button.NAME = buttonname
	new_button.LOCK_COLORS = true

	NOTIFY.NEW_KEYPAD_BUTTON(self._BindingID, new_button)
end


--[[=============================================================================
    KeypadProxy Proxy Commands(PRX_CMD)
===============================================================================]]
function KeypadProxy:prx_BUTTON_ACTION(tParams)
    tParams = tParams or {}
    local cmd = {}
    local btnid = tParams["BUTTON_ID"]
    cmd.BUTTON_ID = btnid
    cmd.ACTION = 1
    NOTIFY.KEYPAD_BUTTON_ACTION(self._BindingID,cmd)
end

--[[=============================================================================
    Camera Proxy Commands(PRX_CMD)
===============================================================================]]
--[[
function CameraProxy:prx_SET_ADDRESS(tParams)
	tParams = tParams or {}
	self._Address = tParams["ADDRESS"] or self._Address
end

function CameraProxy:prx_SET_ADDRESS(tParams)
	tParams = tParams or {}
	self._Address = tParams["ADDRESS"] or self._Address
end
]]



--[[=============================================================================
    Camera Proxy UIRequests
===============================================================================]]
--[[
	Return the query string required for an HTTP image push URL request.
--]]
--[[
function CameraProxy:req_GET_SNAPSHOT_QUERY_STRING(tParams)
	tParams = tParams or {}
    local size_x = tonumber(tParams["SIZE_X"]) or 640
    local size_y = tonumber(tParams["SIZE_Y"]) or 480

	return "<snapshot_query_string>" .. C4:XmlEscapeString(GET_SNAPSHOT_QUERY_STRING(size_x, size_y)) .. "</snapshot_query_string>"
end

]]

--[[=============================================================================
    Camera Proxy Notifies
===============================================================================]]
--[[
function CameraProxy:dev_PropertyDefaults()
	local property_defaults = {}
	property_defaults.HTTP_PORT = C4:GetCapability("default_http_port") or 80
	property_defaults.RTSP_PORT = C4:GetCapability("default_rtsp_port") or 554
	property_defaults.AUTHENTICATION_REQUIRED = C4:GetCapability("default_authentication_required") or true
	property_defaults.AUTHENTICATION_TYPE = C4:GetCapability("default_authentication_type") or "BASIC"
	property_defaults.USERNAME = C4:GetCapability("default_username") or "username"
	property_defaults.PASSWORD = C4:GetCapability("default_password") or "password"

	NOTIFY.PROPERTY_DEFAULTS(self._BindingID, property_defaults)
end

]]
--[[=============================================================================
    Camera Proxy Functions
===============================================================================]]
-- Create class functions required by the class
--[[
function CameraProxy:BuildHTTPURL(queryString)
	local httpUrl = ""
	
	if ((queryString ~= nil) and (string.len(queryString) > 0)) then
		httpUrl = "http://" .. self._Address .. ":" .. self._HttpPort .. "/" .. queryString
	end
	
	return httpUrl
end

]]


 end)
package.preload['keypad.keypad_proxy_commands'] = (function (...)
--[[=============================================================================
    Command Functions Received From Proxy to the Camera Driver

    Copyright 2018 Hiwise Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.keypad_proxy_commands = "2018.05.23"
end

function PRX_CMD.BUTTON_ACTION(idBinding, tParams)
	gKeypadProxy:prx_BUTTON_ACTION(tParams)
end

--[[
function PRX_CMD.SET_ADDRESS(idBinding, tParams)
	gCameraProxy:prx_SET_ADDRESS(tParams)
end

function PRX_CMD.SET_HTTP_PORT(idBinding, tParams)
	gCameraProxy:prx_SET_HTTP_PORT(tParams)
end

function PRX_CMD.SET_RTSP_PORT(idBinding, tParams)
	gCameraProxy:prx_SET_RTSP_PORT(tParams)
end

function PRX_CMD.SET_AUTHENTICATION_REQUIRED(idBinding, tParams)
	gCameraProxy:prx_SET_AUTHENTICATION_REQUIRED(tParams)
end

function PRX_CMD.SET_AUTHENTICATION_TYPE(idBinding, tParams)
	gCameraProxy:prx_SET_AUTHENTICATION_TYPE(tParams)
end

function PRX_CMD.SET_USERNAME(idBinding, tParams)
	gCameraProxy:prx_SET_USERNAME(tParams)
end

function PRX_CMD.SET_PASSWORD(idBinding, tParams)
	gCameraProxy:prx_SET_PASSWORD(tParams)
end

function PRX_CMD.SET_PUBLICLY_ACCESSIBLE(idBinding, tParams)
	gCameraProxy:prx_SET_PUBLICLY_ACCESSIBLE(tParams)
end

function PRX_CMD.PAN_LEFT(idBinding, tParams)
	gCameraProxy:prx_PAN_LEFT()
end

function PRX_CMD.PAN_RIGHT(idBinding, tParams)
	gCameraProxy:prx_PAN_RIGHT()
end

function PRX_CMD.PAN_SCAN(idBinding, tParams)
	gCameraProxy:prx_PAN_SCAN()
end

function PRX_CMD.TILT_UP(idBinding, tParams)
	gCameraProxy:prx_TILT_UP()
end

function PRX_CMD.TILT_DOWN(idBinding, tParams)
	gCameraProxy:prx_TILT_DOWN()
end

function PRX_CMD.TILT_SCAN(idBinding, tParams)
	gCameraProxy:prx_TILT_SCAN()
end

function PRX_CMD.ZOOM_IN(idBinding, tParams)
	gCameraProxy:prx_ZOOM_IN()
end

function PRX_CMD.ZOOM_OUT(idBinding, tParams)
	gCameraProxy:prx_ZOOM_OUT()
end

function PRX_CMD.HOME(idBinding, tParams)
	gCameraProxy:prx_HOME()
end

function PRX_CMD.MOVE_TO(idBinding, tParams)
	gCameraProxy:prx_MOVE_TO(tParams)
end

function PRX_CMD.PRESET(idBinding, tParams)
	gCameraProxy:prx_PRESET(tParams)
end


-- UI Requests
function UI_REQ.GET_SNAPSHOT_QUERY_STRING(tParams)
	return gCameraProxy:req_GET_SNAPSHOT_QUERY_STRING(tParams)
end

function UI_REQ.GET_MJPEG_QUERY_STRING(tParams)
	return gCameraProxy:req_GET_MJPEG_QUERY_STRING(tParams)
end

function UI_REQ.GET_RTSP_H264_QUERY_STRING(tParams)
	return gCameraProxy:req_GET_RTSP_H264_QUERY_STRING(tParams)
end

]] end)
package.preload['keypad.keypad_proxy_notifies'] = (function (...)
--[[=============================================================================
    Notification Functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.keypad_proxy_notifies = "2018.05.23"
end

function NOTIFY.NEW_KEYPAD_BUTTON(bindingID,newbutton)
     LogTrace("NOTIFY.NEW_KEYPAD_BUTTON")
	print("bindingID = ".. bindingID)
     SendNotify("NEW_KEYPAD_BUTTON", newbutton, bindingID)
end

function NOTIFY.KEYPAD_BUTTON_ACTION(bindingID,cmd)
     LogTrace("KEYPAD_BUTTON_ACTION")
	print("bindingID = ".. bindingID) 
     SendNotify("KEYPAD_BUTTON_ACTION", cmd, bindingID)
end

--[[
function NOTIFY.PROPERTY_DEFAULTS(bindingID, tPropertyDefaults)
	LogTrace("NOTIFY.PROPERTY_DEFAULTS")

	SendNotify("PROPERTY_DEFAULTS", tPropertyDefaults, bindingID)
end
]]
 end)
package.preload['proxy_init'] = (function (...)
--[[=============================================================================
    Initialization Functions

    Copyright 2017 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "keypad.keypad_proxy_class"
require "keypad.keypad_proxy_commands"
require "keypad.keypad_proxy_notifies"

IP_DEVICES_ADDR = {}
DEVICE_ADDR = {}
-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.proxy_init = "2017.01.13"
end

function ON_DRIVER_EARLY_INIT.proxy_init()
	-- declare and initialize global variables
end

function ON_DRIVER_INIT.proxy_init()

	gKeypadProxy = KeypadProxy:new(DEFAULT_PROXY_BINDINGID)
end

function ON_DRIVER_LATEINIT.proxy_init()

	gKeypadProxy:dev_Newbuttoncreate(1,"button1")
	gKeypadProxy:dev_Newbuttoncreate(2,"button2")
	gKeypadProxy:dev_Newbuttoncreate(3,"button3")
	gKeypadProxy:dev_Newbuttoncreate(4,"button4")
	gKeypadProxy:dev_Newbuttoncreate(5,"button5")
	gKeypadProxy:dev_Newbuttoncreate(6,"button6")
	
end


 end)
package.preload['proxy_commands'] = (function (...)
--[[=============================================================================
    Commands received from the camera proxy (ReceivedFromProxy)

    Copyright 2017 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.proxy_commands = "2017.01.13"
end

--[[
	Implement the following commands as required by capabilities. 
--]]
--[[
function PAN_LEFT()
	-- TODO: Set the value of the PAN_LEFT command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("PAN_LEFT(): Ticket = " .. ticket .. " URL = " .. url)
end

function PAN_RIGHT()
	-- TODO: Set the value of the PAN_RIGHT command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("PAN_RIGHT(): Ticket = " .. ticket .. " URL = " .. url)
end

function PAN_SCAN()
	-- TODO: Set the value of the PAN_SCAN command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("PAN_SCAN(): Ticket = " .. ticket .. " URL = " .. url)
end

function TILT_UP()
	-- TODO: Set the value of the TILT_UP command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("TILT_UP(): Ticket = " .. ticket .. " URL = " .. url)
end

function TILT_DOWN()
	-- TODO: Set the value of the TILT_DOWN command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("TILT_DOWN(): Ticket = " .. ticket .. " URL = " .. url)
end

function TILT_SCAN()
	-- TODO: Set the value of the TILT_SCAN command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("TILT_SCAN(): Ticket = " .. ticket .. " URL = " .. url)
end

function ZOOM_IN()
	-- TODO: Set the value of the ZOOM_IN command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("ZOOM_IN(): Ticket = " .. ticket .. " URL = " .. url)
end

function ZOOM_OUT()
	-- TODO: Set the value of the ZOOM_OUT command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("ZOOM_OUT(): Ticket = " .. ticket .. " URL = " .. url)
end

function HOME()
	-- TODO: Set the value of the HOME command
	local command = "" 

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("HOME(): Ticket = " .. ticket .. " URL = " .. url)
end
]]

--[[

function PRESET(index)
	-- TODO: Set the value of the PRESET command
	local command = ""

	local url = gCameraProxy:BuildHTTPURL(command)
	local ticket = gCon:UrlGet(gCameraProxy:BuildGetRequest(url), gCameraProxy:AuthHeader())
	
	LogTrace("PRESET(" .. tostring(index) .. "): Ticket = " .. ticket .. " URL = " .. url)
end
]]
-- UI Requests
--[[
	Return the query string required for an HTTP snapshot URL request.
--]]
--[[
function GET_SNAPSHOT_QUERY_STRING(size_x, size_y)
	-- TODO: Set the URL query string between the quotes.  Remember there should be no leading /
	-- If the camera has the ability to send a snapshot of a particular size then use the size_x and size_y variables in the query.
	local snapshotQueryString = "sample/queryString?parameter=value&parameter2=value2"

	return snapshotQueryString
end
]]
--[[
	Return the query string required for an MJPEG HTTP image push URL request.
--]]
--[[
function GET_MJPEG_QUERY_STRING(size_x, size_y, period)
    local mjpegQueryString = ""
    
	-- TODO: Set the MJPEG URL query string between the quotes.  Remember there should be no leading /
	-- If the camera has the ability to provide an MJPEG stream of a particular resolution, then use the size_x and size_y variables in the query.
    -- If the camera has the ability to provide an MJPEG stream at a particular frame rate/period, then use the period variable in the query.
    
    -- If the camera supports multiple stream configurations, the property gCameraProxy._MJPEG_Stream_ID can be used in the query to specify
    --   which stream to use for MJPEG.
    -- mjpegQueryString = "sample/queryString?camera=" .. tostring(gCameraProxy._MJPEG_Stream_ID) .. "&parameter2=value2"
    
    -- If the camera supports multiple stream configurations using profiles, the property gCameraProxy._MJPEG_Stream_Profile can be used in the query to specify
    --   which stream to use for MJPEG.
    -- mjpegQueryString = "sample/queryString?profile=" .. gCameraProxy._MJPEG_Stream_Profile .. "&parameter2=value2"
    
    -- mjpegQueryString = "sample/queryString?resolution=" .. tostring(size_x) .. "x" .. tostring(size_y) .. "&parameter2=value2"

	return mjpegQueryString
end
]]
--[[
	Return the query string required to establish Rtsp connection.
--]]
--[[
function GET_RTSP_H264_QUERY_STRING(size_x, size_y, period)
    local rtspH264QueryString = ""
    
	-- TODO: Set the H264 URL query string between the quotes.  Remember there should be no leading /
	-- If the camera has the ability to provide an H264 stream of a particular resolution then use the size_x and size_y variables in the query.
    -- If the camera has the ability to provide an H264 stream at a particular frame rate/period, then use the period variable in the query.
    
    -- If the camera supports multiple stream configurations using stream IDs or profiles,  
    --   use the size to specify the best stream for the resolution requested.
    if (size_y == 2160) then -- 4K
        -- The property gCameraProxy._H264_4K_Stream_ID can be used in the query to specify which stream to use for H264 4K.
        -- rtspH264QueryString = "sample/queryString?camera=" .. tostring(gCameraProxy._H264_4K_Stream_ID) .. "&parameter2=value2"
        
        -- The property gCameraProxy._H264_4K_Stream_Profile can be used in the query to specify which stream to use for H264 4K.
        -- rtspH264QueryString = "sample/queryString?profile=" .. gCameraProxy._H264_4K_Stream_Profile .. "&parameter2=value2"
    elseif (size_y == 1080) then
        -- The property gCameraProxy._H264_1080p_Stream_ID can be used in the query to specify which stream to use for H264 1080p.
        -- rtspH264QueryString = "sample/queryString?camera=" .. tostring(gCameraProxy._H264_1080p_Stream_ID) .. "&parameter2=value2"
        
        -- The property gCameraProxy._H264_1080p_Stream_Profile can be used in the query to specify which stream to use for H264 1080p.
        -- rtspH264QueryString = "sample/queryString?profile=" .. gCameraProxy._H264_1080p_Stream_Profile .. "&parameter2=value2"   
    elseif (size_y == 720) then
        -- The property gCameraProxy._H264_720p_Stream_ID can be used in the query to specify which stream to use for H264 720p.
        -- rtspH264QueryString = "sample/queryString?camera=" .. tostring(gCameraProxy._H264_720p_Stream_ID) .. "&parameter2=value2"
        
        -- The property gCameraProxy._H264_720p_Stream_Profile can be used in the query to specify which stream to use for H264 720p.
        -- rtspH264QueryString = "sample/queryString?profile=" .. gCameraProxy._H264_720p_Stream_Profile .. "&parameter2=value2"
    else
        -- The property gCameraProxy._H264_Stream_ID can be used in the query to specify which stream to use for H264.
	    -- rtspH264QueryString = "sample/queryString?camera=" .. tostring(gCameraProxy._H264_Stream_ID) .. "&parameter2=value2"
        
        -- The property gCameraProxy._H264_Stream_Profile can be used in the query to specify which stream to use for H264.
        -- rtspH264QueryString = "sample/queryString?profile=" .. gCameraProxy._H264_Stream_Profile .. "&parameter2=value2"   
    end
    
    -- rtspH264QueryString = "sample/queryString?resolution=" .. tostring(size_x) .. "x" .. tostring(size_y) .. "&parameter2=value2"
	
	return rtspH264QueryString
end
]]
 end)
--[[=============================================================================
    Main script file for driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_common"
require "common.c4_init"
require "common.c4_property"
require "common.c4_command"
require "common.c4_notify"
require "common.c4_utils"
require "lib.c4_timer"
require "actions"
require "device_specific_commands"
require "device_messages"
require "proxy_init"
require "properties"
require "proxy_commands"
require "connections"

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.driver = "2016.01.08"
end

--[[=============================================================================
    Initialization Code
===============================================================================]]
function ON_DRIVER_EARLY_INIT.main()
	
end

function ON_DRIVER_INIT.main()
	-- TODO: Change the logger name
	SetLogName("Template_c4z")

	-- TODO: If cloud based driver then uncomment the following line
	--ConnectURL()
end

function ON_DRIVER_LATEINIT.main()
	--C4:urlSetTimeout (20)
end
